{
        "1": {
          "title": "Random Module",
          "description": "This module focuses on working with pseudorandom sequences, which are essential in mathematical modeling, cryptography, and various games.",
          "tasks": {
            "task_1": {
              "type": "theoretical",
              "title": "Introduction to random module",
              "description": "Этот модуль предназначен для работы с псевдослучайными последовательностями. Такие последовательности важны в математическом моделировании, в криптографии и в различных играх.",
              "content": {
                "overview": "Модуль 'random' предоставляет множество функций для генерации псевдослучайных чисел и последовательностей.",
                "structure": {
                  "example": ">>> import random\n>>> dir(random)\n['BPF', ... , 'choice', ... , 'randint', 'random', 'randrange', 'sample', 'seed', 'setstate', 'shuffle', 'triangular', ...]"
                },
                "functions": {
                  "randint": {
                    "description": "Генерирует случайное целое число между заданными границами (включительно).",
                    "example": "from random import randint\nprint(randint(10, 20))"
                  },
                  "randrange": {
                    "description": "Генерирует случайное число из диапазона с опциональной возможностью задать шаг.",
                    "example": "from random import randrange\nprint(randrange(40, 100, 5))"
                  },
                  "choice": {
                    "description": "Выбирает случайный элемент из последовательности (список, кортеж, строка и т.д.).",
                    "examples": [
                      "from random import choice\nprint(choice(['heads', 'tails']))",
                      "from random import choice\nprint(choice([1, 2, 3]))",
                      "choice(\"ab\")"
                    ]
                  },
                  "dice_simulation": {
                    "description": "Симуляция бросков кубиков с использованием функции choice.",
                    "example": "from random import choice\n\n# Симуляция нескольких бросков кубиков\nfor i in range(1, 10):\n    print(choice([1, 2, 3, 4, 5, 6]), choice([1, 2, 3, 4, 5, 6]))"
                  },
                  "unicode_dice_simulation": {
                    "description": "Симуляция бросков игральных кубиков с символами Unicode.",
                    "example": "from random import choice\n\ndashes = ['\\u2680', '\\u2681', '\\u2682', '\\u2683', '\\u2684', '\\u2685']\nfor i in range(1, 10):\n    print(choice(dashes), choice(dashes))"
                  },
                  "magic_8_ball": {
                    "description": "Симуляция магического шара, отвечающего на вопросы 'да' или 'нет'.",
                    "example": "from random import choice\n\nchoices = [\n    'It is certain (Бесспорно)',\n    'It is decidedly so (Предрешено)',\n    'Without a doubt (Никаких сомнений)',\n    'Yes — definitely (Определённо да)',\n    'You may rely on it (Можешь быть уверен в этом)',\n    'As I see it, yes (Мне кажется — «да»)',\n    'Most likely (Вероятнее всего)',\n    'Outlook good (Хорошие перспективы)',\n    'Signs point to yes (Знаки говорят — «да»)',\n    'Yes (Да)',\n    'Reply hazy, try again (Пока не ясно, попробуй снова)',\n    'Ask again later (Спроси позже)',\n    'Better not tell you now (Лучше не рассказывать)',\n    'Cannot predict now (Сейчас нельзя предсказать)',\n    'Concentrate and ask again (Соберись и спроси опять)',\n    'Don’t count on it (Даже не думай)',\n    'My reply is no (Мой ответ — «нет»)',\n    'My sources say no (По моим данным — «нет»)',\n    'Outlook not so good (Перспективы не очень хорошие)',\n    'Very doubtful (Весьма сомнительно)'\n]\n\nfor i in range(5):\n    input('Ваш вопрос: ')\n    print(choice(choices))"
                  },
                  "choices": {
                    "description": "Выбор нескольких случайных элементов с возможностью повторений.",
                    "example": "from random import choices\nprint(choices(['Yes', 'No', 'Maybe'], k=5))"
                  },
                  "sample": {
                    "description": "Возвращает несколько случайных элементов без повторений.",
                    "example": "from random import sample\nprint(sample(range(10), 6))"
                  },
                  "shuffle": {
                    "description": "Перемешивает список на месте.",
                    "example": "from random import shuffle\na = list(range(100))\nshuffle(a)\nprint(a[:10])"
                  },
                  "random": {
                    "description": "Генерирует случайное вещественное число в диапазоне от 0 до 1 (не включительно).",
                    "example": "from random import random as rnd\nprint(rnd())"
                  }
                }
              }
            },
            "task_2": {
              "title": "Random type of application",
              "type": "practical",
              "description": "Write a program to create a list of types of applications and output random choice.",
              "explanation": {
            "beginner": {
                "title": "What Are We Doing?",
                "content": [
                    {
                        "tag": "concept",
                        "text": "We're creating a program that randomly selects a number from a range."
                    },
                    {
                        "tag": "analogy",
                        "text": "Think of it like drawing a card from a deck of cards numbered 11 to 20."
                    },
                    {
                        "tag": "action",
                        "text": "Each time we run the program, it randomly picks a number from our deck."
                    },
                    {
                        "tag": "example",
                        "text": "If the program picks 15, that's the number we've drawn!"
                    },
                    {
                        "tag": "tool",
                        "text": "We’ll use Python’s 'random' module to help with this selection."
                    }
                ]
            },
            "intermediate": {
                "title": "What's Happening Here?",
                "content": [
                    {
                        "tag": "goal",
                        "text": "Our goal is to generate a random integer within the range of 11 to 20."
                    },
                    {
                        "tag": "library",
                        "text": "The 'random' library in Python allows us to generate random numbers."
                    },
                    {
                        "tag": "functionality",
                        "text": "By using a function from this library, we specify the range and receive a random number."
                    },
                    {
                        "tag": "note",
                        "text": "Each execution of the program can yield a different number, adding an element of surprise."
                    },
                    {
                        "tag": "example",
                        "text": "One time it could output 12, and another time it could be 18."
                    },
                    {
                        "tag": "application",
                        "text": "This feature is particularly useful in games and simulations where unpredictability is key."
                    }
                ]
            },
            "advanced": {
                "title": "Deep Dive",
                "content": [
                    {
                        "tag": "goal",
                        "text": "The aim is to output a random integer within the inclusive range of [11, 20]."
                    },
                    {
                        "tag": "library",
                        "text": "We will use the 'random' library, specifically the 'randint' function, to achieve this."
                    },
                    {
                        "tag": "parameters",
                        "text": "The randint function takes two parameters: the minimum and maximum values of our range."
                    },
                    {
                        "tag": "note",
                        "text": "Due to its randomness, the output varies with each execution, which is crucial for applications needing unpredictability."
                    }
                ]
            }
        },
              "solution": {
                "code": "import random\n\nrandom_number = random.randint(11, 20)\nprint(random_number)",
                "steps": [
                  {
                    "step_1": {
                      "code_line": "import random",
                      "description": "This line imports the 'random' module, which contains functions to generate random numbers. It is like opening a toolbox that has tools for randomness."
                    }
                  },
                  {
                    "step_2": {
                      "code_line": "random_number = random.randint(11, 20)",
                      "description": {
                        "random.randint(11, 20)": "This function call generates a random number between 11 and 20 (inclusive). Each time you run the program, you might get a different number."
                      }
                    }
                  },
                  {
                    "step_3": {
                      "code_line": "print(random_number)",
                      "description": "This line prints the random number generated by 'randint' to the console."
                    }
                  }
                ]
              }
            },
            "task_3": {
                "title": "Random type of application",
                "type": "practical",
                "description": "Write a program to create a list of types of applications and output random choice.\n\nNote: type of applications find in the Internet.",
                "explanation": {
                "beginner": {
                    "title": "What Are We Doing?",
                    "content": [
                    {
                        "tag": "concept",
                        "text": "We need to create a list of different types of applications (like mobile apps, web apps, etc.) and randomly choose one from this list."
                    },
                    {
                        "tag": "analogy",
                        "text": "Think of a hat filled with different types of papers, each representing a type of application. Our goal is to randomly pick one paper from the hat."
                    },
                    {
                        "tag": "action",
                        "text": "In this task, we will use a computer to pick one random type from a list of application types, like how you might randomly pick a name from a hat."
                    },
                    {
                        "tag": "tool",
                        "text": "We’ll use the 'random' module in Python to help us randomly select a type from our list."
                    }
                    ]
                },
                "intermediate": {
                    "title": "What's Happening Here?",
                    "content": [
                    {
                        "tag": "goal",
                        "text": "Our goal is to create a list of different application types (e.g., web apps, mobile apps, desktop apps, etc.) and randomly select one."
                    },
                    {
                        "tag": "library",
                        "text": "To achieve this, we’ll use the 'random' module, specifically the 'choice' function, which picks one item from a list at random."
                    },
                    {
                        "tag": "example",
                        "text": "For instance, if our list has types like 'Mobile Application' and 'Web Application,' our program might randomly select 'Web Application' when we run it."
                    },
                    {
                        "tag": "use_case",
                        "text": "This kind of randomness is useful when we need to make selections or decisions in a game or simulation."
                    }
                    ]
                },
                "advanced": {
                    "title": "Deep Dive",
                    "content": [
                    {
                        "tag": "goal",
                        "text": "The objective is to create a list of various types of software applications (e.g., mobile apps, web apps, desktop apps, etc.) and output a random choice using Python’s 'random.choice' method."
                    },
                    {
                        "tag": "library",
                        "text": "We will use the 'random' module in Python, specifically the 'choice' function, which randomly selects one item from a list. This is helpful when simulating randomness in decision-making or data sampling."
                    },
                    {
                        "tag": "application",
                        "text": "In the context of this task, the 'random.choice' method will help simulate selecting a random type of application from a predetermined list."
                    },
                    {
                        "tag": "further_usage",
                        "text": "This technique can be extended for various use cases like randomly assigning tasks, selecting items in games, or creating simulations."
                    }
                    ]
                }
                },
                "solution": {
                "code": "import random\n\n# Step 1: Create a list of application types\napplication_types = ['Mobile Application', 'Web Application', 'Desktop Application', 'Cloud Application', 'Game Application', 'Embedded Application']\n\n# Step 2: Use random.choice to select a random application type\nrandom_choice = random.choice(application_types)\n\n# Step 3: Print the randomly selected application type\nprint('Randomly selected application type:', random_choice)",
                "steps": [
                    {
                    "step_1": {
                        "code_line": "import random",
                        "description": "We start by importing the 'random' module, which contains the 'choice' function that allows us to make a random selection."
                    }
                    },
                    {
                    "step_2": {
                        "code_line": "application_types = ['Mobile Application', 'Web Application', 'Desktop Application', 'Cloud Application', 'Game Application', 'Embedded Application']",
                        "description": {
                        "goal": "In this step, we create a list that contains various types of software applications.",
                        "note": "You can find different types of applications by searching the Internet and add them to the list."
                        }
                    }
                    },
                    {
                    "step_3": {
                        "code_line": "random_choice = random.choice(application_types)",
                        "description": {
                        "function": "'random.choice' is used to pick one random item from the 'application_types' list.",
                        "note": "Every time you run the program, a different type of application may be selected."
                        }
                    }
                    },
                    {
                    "step_4": {
                        "code_line": "print('Randomly selected application type:', random_choice)",
                        "description": "This line prints the randomly selected application type to the console."
                    }
                    }
                ]
                }
            },
            "task_4": {
                "title": "Shuffle",
                "type": "practical",
                "description": "Write a program to shuffle numbers between 0 and 10 (not inclusive).",
                "explanation": {
                "beginner": {
                    "title": "What Are We Doing?",
                    "content": [
                    {
                        "tag": "concept",
                        "text": "We need to shuffle (randomly mix) a set of numbers between 1 and 9."
                    },
                    {
                        "tag": "analogy",
                        "text": "Imagine you have cards numbered 1 to 9. Our goal is to shuffle those cards, mixing them into a random order."
                    },
                    {
                        "tag": "action",
                        "text": "In this task, we will use Python to shuffle numbers between 1 and 9."
                    },
                    {
                        "tag": "tool",
                        "text": "We’ll use the 'random' module in Python to shuffle a list of numbers."
                    }
                    ]
                },
                "intermediate": {
                    "title": "What's Happening Here?",
                    "content": [
                    {
                        "tag": "goal",
                        "text": "Our goal is to shuffle a list of numbers from 1 to 9. Shuffling means randomly changing the order of the numbers."
                    },
                    {
                        "tag": "library",
                        "text": "We’ll use the 'random.shuffle' function, which will randomly rearrange the elements in our list."
                    },
                    {
                        "tag": "example",
                        "text": "If the original list is [1, 2, 3, 4, 5, 6, 7, 8, 9], after shuffling it could look like [7, 3, 1, 6, 2, 9, 8, 5, 4]."
                    },
                    {
                        "tag": "use_case",
                        "text": "This technique is useful in situations like card games, where you need to shuffle a deck randomly."
                    }
                    ]
                },
                "advanced": {
                    "title": "Deep Dive",
                    "content": [
                    {
                        "tag": "goal",
                        "text": "The objective is to shuffle a list of numbers from 1 to 9 using the 'random.shuffle' method in Python."
                    },
                    {
                        "tag": "library",
                        "text": "'random.shuffle' takes a list and rearranges its elements in a random order. It operates in-place, meaning it directly changes the order of the items in the list without creating a new list."
                    },
                    {
                        "tag": "application",
                        "text": "Shuffling is important in many contexts, like shuffling cards, creating randomized data samples, or preparing data for machine learning algorithms."
                    },
                    {
                        "tag": "further_usage",
                        "text": "Beyond just shuffling numbers, this method can be used to shuffle other types of lists, like lists of strings or even complex objects."
                    }
                    ]
                }
                },
                "solution": {
                "code": "import random\n\n# Step 1: Create a list of numbers between 1 and 9\nnumbers = list(range(1, 10))\n\n# Step 2: Shuffle the list using random.shuffle\nrandom.shuffle(numbers)\n\n# Step 3: Print the shuffled list\nprint('Shuffled list:', numbers)",
                "steps": [
                    {
                    "step_1": {
                        "code_line": "import random",
                        "description": "We import the 'random' module, which contains the 'shuffle' function that allows us to shuffle the list."
                    }
                    },
                    {
                    "step_2": {
                        "code_line": "numbers = list(range(1, 10))",
                        "description": {
                        "goal": "We create a list of numbers from 1 to 9 using 'range(1, 10)' and convert it into a list.",
                        "note": "'range(1, 10)' generates numbers starting from 1 up to, but not including, 10."
                        }
                    }
                    },
                    {
                    "step_3": {
                        "code_line": "random.shuffle(numbers)",
                        "description": {
                        "function": "'random.shuffle' is used to rearrange the elements in the list randomly.",
                        "note": "This changes the order of the numbers in the list in-place."
                        }
                    }
                    },
                    {
                    "step_4": {
                        "code_line": "print('Shuffled list:', numbers)",
                        "description": "This line prints the shuffled list of numbers to the console."
                    }
                    }
                ]
                }
            },
            "task_5": {
                "title": "Sportloto",
                "type": "practical",
                "description": "Write a program to implement 'Sportloto' 5 from 36. Output five random numbers in ascending order.",
                "explanation": {
                "beginner": {
                    "title": "What Are We Doing?",
                    "content": [
                    {
                        "tag": "concept",
                        "text": "We need to randomly pick five numbers from 1 to 36, just like picking numbers in a lottery."
                    },
                    {
                        "tag": "analogy",
                        "text": "Think of this as pulling five balls from a bag that contains 36 numbered balls."
                    },
                    {
                        "tag": "action",
                        "text": "We'll use Python to randomly choose 5 numbers and then arrange them in ascending order."
                    },
                    {
                        "tag": "tool",
                        "text": "We’ll use the 'random.sample' function to pick the numbers and the 'sorted' function to order them."
                    }
                    ]
                },
                "intermediate": {
                    "title": "What's Happening Here?",
                    "content": [
                    {
                        "tag": "goal",
                        "text": "Our goal is to simulate a lottery draw by selecting 5 random numbers from 1 to 36 and sorting them in ascending order."
                    },
                    {
                        "tag": "library",
                        "text": "We will use the 'random.sample' function, which lets us pick a specified number of unique random elements from a given range."
                    },
                    {
                        "tag": "example",
                        "text": "If the numbers drawn are [18, 3, 25, 14, 9], they will be sorted to give [3, 9, 14, 18, 25]."
                    },
                    {
                        "tag": "use_case",
                        "text": "This is used in games of chance like lotteries, where you need to pick several numbers randomly."
                    }
                    ]
                },
                "advanced": {
                    "title": "Deep Dive",
                    "content": [
                    {
                        "tag": "goal",
                        "text": "The objective is to select 5 unique random numbers from 1 to 36 and sort them in ascending order using Python."
                    },
                    {
                        "tag": "library",
                        "text": "'random.sample' generates a list of unique random numbers from a specified range without repetition. 'sorted' orders the list in ascending order."
                    },
                    {
                        "tag": "application",
                        "text": "This technique can be extended to any situation where you need to generate a random subset from a larger group, such as picking raffle winners."
                    },
                    {
                        "tag": "further_usage",
                        "text": "Besides lottery simulation, 'random.sample' is useful for selecting random subsets of data, like drawing random samples from a dataset for analysis."
                    }
                    ]
                }
                },
                "solution": {
                "code": "import random\n\n# Step 1: Generate 5 random unique numbers from 1 to 36\nnumbers = random.sample(range(1, 37), 5)\n\n# Step 2: Sort the numbers in ascending order\nnumbers_sorted = sorted(numbers)\n\n# Step 3: Print the sorted list\nprint('Sportloto numbers:', numbers_sorted)",
                "steps": [
                    {
                    "step_1": {
                        "code_line": "import random",
                        "description": "We import the 'random' module, which provides the function to generate random numbers."
                    }
                    },
                    {
                    "step_2": {
                        "code_line": "numbers = random.sample(range(1, 37), 5)",
                        "description": {
                        "goal": "We use 'random.sample' to randomly select 5 unique numbers from 1 to 36.",
                        "note": "'range(1, 37)' generates numbers from 1 to 36."
                        }
                    }
                    },
                    {
                    "step_3": {
                        "code_line": "numbers_sorted = sorted(numbers)",
                        "description": {
                        "goal": "We use the 'sorted' function to sort the randomly chosen numbers in ascending order."
                        }
                    }
                    },
                    {
                    "step_4": {
                        "code_line": "print('Sportloto numbers:', numbers_sorted)",
                        "description": "This line prints the sorted list of numbers to the console."
                    }
                    }
                ]
                }
            },
            "task_6": {
    "title": "Heads or tails",
    "type": "practical",
    "description": "Write a program that simulates tossing coins. The number of attempts is entered from the keyboard. The program should display the results of the rolls: heads or tails.",
    "explanation": {
      "beginner": {
        "title": "What Are We Doing?",
        "content": [
          {
            "tag": "concept",
            "text": "We will simulate tossing a coin multiple times and output whether it's heads or tails for each toss."
          },
          {
            "tag": "action",
            "text": "You'll enter how many times to toss the coin, and the program will randomly choose heads or tails for each toss."
          },
          {
            "tag": "tool",
            "text": "We'll use the 'random.choice' function to randomly pick 'heads' or 'tails'."
          }
        ]
      },
      "intermediate": {
        "title": "What's Happening Here?",
        "content": [
          {
            "tag": "goal",
            "text": "We want to simulate flipping a coin and record whether each flip is heads or tails."
          },
          {
            "tag": "library",
            "text": "'random.choice' allows us to pick randomly between two outcomes: 'heads' or 'tails'."
          },
          {
            "tag": "input",
            "text": "The user will input how many times to flip the coin, and the program will execute that many flips."
          },
          {
            "tag": "output",
            "text": "For each flip, the program will output either 'heads' or 'tails'."
          }
        ]
      },
      "advanced": {
        "title": "Deep Dive",
        "content": [
          {
            "tag": "goal",
            "text": "Our objective is to simulate tossing a coin multiple times and recording the result for each toss, using Python."
          },
          {
            "tag": "library",
            "text": "'random.choice' randomly selects one value from the list ['heads', 'tails'] for each toss."
          },
          {
            "tag": "application",
            "text": "This technique can be applied to any binary outcome simulation, such as simulating success/failure or win/loss scenarios."
          },
          {
            "tag": "further_usage",
            "text": "This concept of simulation can be extended to other areas like simulating dice rolls or probability-based events."
          }
        ]
      }
    },
    "solution": {
      "code": "import random\n\n# Step 1: Ask user how many times to toss the coin\nattempts = int(input('Enter the number of attempts: '))\n\n# Step 2: Simulate each coin toss\nfor _ in range(attempts):\n    result = random.choice(['heads', 'tails'])\n    print(result)",
      "steps": [
        {
          "step_1": {
            "code_line": "import random",
            "description": "We import the 'random' module, which provides functions for generating random results."
          }
        },
        {
          "step_2": {
            "code_line": "attempts = int(input('Enter the number of attempts: '))",
            "description": {
              "goal": "We ask the user to input how many times they want to flip the coin.",
              "note": "The 'int' function converts the input into an integer."
            }
          }
        },
        {
          "step_3": {
            "code_line": "for _ in range(attempts):",
            "description": {
              "goal": "We set up a loop to repeat the coin flip for the number of attempts the user entered."
            }
          }
        },
        {
          "step_4": {
            "code_line": "result = random.choice(['heads', 'tails'])",
            "description": {
              "goal": "We use 'random.choice' to randomly pick either 'heads' or 'tails'."
            }
          }
        },
        {
          "step_5": {
            "code_line": "print(result)",
            "description": "This line outputs the result ('heads' or 'tails') of each coin flip."
          }
        }
      ]
    }
  },
  "task_7": {
    "title": "Secret Santa",
    "type": "practical",
    "description": "Write a program that determines the 'Secret Santa' for all students in the class. A student cannot be a 'Secret Santa' for themselves.",
    "explanation": {
      "beginner": {
        "title": "What Are We Doing?",
        "content": [
          {
            "tag": "concept",
            "text": "We will randomly assign each student in the class to another student as their 'Secret Santa.'"
          },
          {
            "tag": "action",
            "text": "The program will shuffle the list of students and pair them up for gift-giving."
          },
          {
            "tag": "tool",
            "text": "We'll use the 'random.shuffle' function to mix up the list of students."
          }
        ]
      },
      "intermediate": {
        "title": "What's Happening Here?",
        "content": [
          {
            "tag": "goal",
            "text": "We want to create a random pairing of students where each student gives a gift to another."
          },
          {
            "tag": "library",
            "text": "Using 'random.shuffle', we randomize the order of students so that each pairing is different each time."
          },
          {
            "tag": "loop",
            "text": "We loop through the list to assign each student a Secret Santa from the shuffled list."
          }
        ]
      },
      "advanced": {
        "title": "Deep Dive",
        "content": [
          {
            "tag": "goal",
            "text": "The objective is to implement a fair Secret Santa assignment that avoids self-pairing."
          },
          {
            "tag": "algorithm",
            "text": "After shuffling, we assign each student to the next one in the list, with the last student assigned to the first."
          },
          {
            "tag": "application",
            "text": "This method ensures randomness and fairness, making it applicable to various assignment scenarios."
          }
        ]
      }
    },
    "solution": {
      "code": "import random\n\n# Step 1: List of students\nstudents = [\"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eve\"]\n\n# Step 2: Shuffle the list\nrandom.shuffle(students)\n\n# Step 3: Create Secret Santa assignments\nsecret_santa = {}\nfor i in range(len(students)):\n    if i == len(students) - 1:\n        secret_santa[students[i]] = students[0]\n    else:\n        secret_santa[students[i]] = students[i + 1]\n\n# Step 4: Print the results\nfor giver, receiver in secret_santa.items():\n    print(f'{giver} is Secret Santa for {receiver}.')",
      "steps": [
        {
          "step_1": {
            "code_line": "import random",
            "description": "We import the 'random' module to use randomization functions."
          }
        },
        {
          "step_2": {
            "code_line": "students = [\"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eve\"]",
            "description": "We create a list containing the names of students participating in Secret Santa."
          }
        },
        {
          "step_3": {
            "code_line": "random.shuffle(students)",
            "description": "This line randomizes the order of students in the list."
          }
        },
        {
          "step_4": {
            "code_line": "secret_santa = {}",
            "description": "We initialize an empty dictionary to store the Secret Santa assignments."
          }
        },
        {
          "step_5": {
            "code_line": "for i in range(len(students)):",
            "description": "We loop through the list of students to create the Secret Santa assignments."
          }
        },
        {
          "step_6": {
            "code_line": "if i == len(students) - 1:\n    secret_santa[students[i]] = students[0]",
            "description": "If we're at the last student, we assign them to the first student in the list."
          }
        },
        {
          "step_7": {
            "code_line": "else:\n    secret_santa[students[i]] = students[i + 1]",
            "description": "For all other students, we assign them to the next student in the shuffled list."
          }
        },
        {
          "step_8": {
            "code_line": "for giver, receiver in secret_santa.items():\n    print(f'{giver} is Secret Santa for {receiver}.')",
            "description": "Finally, we print each student's Secret Santa assignment."
          }
        }
      ]
    }
  },
  "task_8": {
    "title": "Magic ball",
    "type": "practical",
    "description": "Write a program to create the program 'Magic ball' that gives random answers to yes or no questions.",
    "explanation": {
      "beginner": {
        "title": "What Are We Doing?",
        "content": [
          {
            "tag": "concept",
            "text": "We will create a program that simulates a magic 8-ball, providing random answers to questions."
          },
          {
            "tag": "action",
            "text": "You'll input a question, and the program will return a random answer from a predefined list."
          },
          {
            "tag": "tool",
            "text": "We'll use the 'random.choice' function to select an answer randomly from our list."
          }
        ]
      },
      "intermediate": {
        "title": "What's Happening Here?",
        "content": [
          {
            "tag": "goal",
            "text": "The program aims to provide a fun way to answer yes or no questions randomly."
          },
          {
            "tag": "library",
            "text": "We utilize 'random.choice' to select one answer from a list of possible responses."
          },
          {
            "tag": "input_output",
            "text": "The user will input a question, and the program will output a random answer."
          }
        ]
      },
      "advanced": {
        "title": "Deep Dive",
        "content": [
          {
            "tag": "goal",
            "text": "Our objective is to simulate a magic 8-ball that gives users random yet predefined responses to their questions."
          },
          {
            "tag": "algorithm",
            "text": "By gathering a list of potential responses and using randomization, we can create an interactive experience."
          },
          {
            "tag": "application",
            "text": "This technique can be extended to create other interactive programs that require random outputs based on user input."
          }
        ]
      }
    },
    "solution": {
      "code": "import random\n\n# Step 1: List of possible answers\nanswers = [\n    \"It is certain.\",\n    \"It is decidedly so.\",\n    \"Without a doubt.\",\n    \"Yes definitely.\",\n    \"You may rely on it.\",\n    \"As I see it, yes.\",\n    \"Most likely.\",\n    \"Outlook good.\",\n    \"Yes.\",\n    \"Signs point to yes.\",\n    \"Reply hazy, try again.\",\n    \"Ask again later.\",\n    \"Better not tell you now.\",\n    \"Cannot predict now.\",\n    \"Concentrate and ask again.\",\n    \"Don't count on it.\",\n    \"My reply is no.\",\n    \"My sources say no.\",\n    \"Outlook not so good.\",\n    \"Very doubtful.\"\n]\n\n# Step 2: Ask the user for a question\ninput('Ask your question: ')\n\n# Step 3: Get a random answer\nanswer = random.choice(answers)\n\n# Step 4: Print the answer\nprint(answer)",
      "steps": [
        {
          "step_1": {
            "code_line": "import random",
            "description": "We import the 'random' module to use random selection functions."
          }
        },
        {
          "step_2": {
            "code_line": "answers = [ ... ]",
            "description": "We define a list of possible answers that the magic ball can provide."
          }
        },
        {
          "step_3": {
            "code_line": "input('Ask your question: ')",
            "description": "We prompt the user to input their question. The input is not stored since we only need to ask the question."
          }
        },
        {
          "step_4": {
            "code_line": "answer = random.choice(answers)",
            "description": "We use 'random.choice' to randomly select an answer from our list of possible responses."
          }
        },
        {
          "step_5": {
            "code_line": "print(answer)",
            "description": "This line outputs the randomly chosen answer to the user's question."
          }
        }
      ]
    }
  },
  "task_9": {
    "title": "Guess number",
    "type": "practical",
    "description": "Write a program to create a simple number guessing game where the computer chooses a random number between 0 and 100 and provides hints until the player guesses the number.",
    "explanation": {
      "beginner": {
        "title": "What Are We Doing?",
        "content": [
          {
            "tag": "concept",
            "text": "We will create a game where the computer picks a number, and you have to guess it with hints."
          },
          {
            "tag": "action",
            "text": "You'll keep guessing until you find the right number, and the program will guide you with hints."
          },
          {
            "tag": "tool",
            "text": "We'll use the 'random' module to generate a number and conditionals to provide hints."
          }
        ]
      },
      "intermediate": {
        "title": "What's Happening Here?",
        "content": [
          {
            "tag": "goal",
            "text": "The program is designed to challenge the user to guess a number while providing feedback."
          },
          {
            "tag": "library",
            "text": "We use the 'random' module to select a number randomly from the range 0 to 100."
          },
          {
            "tag": "input_output",
            "text": "The user will enter guesses, and the program will tell them whether to go higher or lower."
          }
        ]
      },
      "advanced": {
        "title": "Deep Dive",
        "content": [
          {
            "tag": "goal",
            "text": "Our objective is to create an interactive guessing game that uses basic programming concepts."
          },
          {
            "tag": "algorithm",
            "text": "By using loops and conditionals, we can guide the user through the guessing process efficiently."
          },
          {
            "tag": "application",
            "text": "This approach can be applied to various game designs and user interaction scenarios."
          }
        ]
      }
    },
    "solution": {
      "code": "import random\n\n# Step 1: Generate a random number\nnumber_to_guess = random.randint(0, 100)\n\n# Step 2: Initialize a variable to track guesses\nguess = None\n\n# Step 3: Loop until the user guesses the number\nwhile guess != number_to_guess:\n    # Step 4: Get user's guess\n    guess = int(input('Guess a number between 0 and 100: '))\n    \n    # Step 5: Provide hints\n    if guess < number_to_guess:\n        print('GO UP')\n    elif guess > number_to_guess:\n        print('GO DOWN')\n\n# Step 6: Congratulate the user\nprint('Congratulations! You guessed the number!')",
      "steps": [
        {
          "step_1": {
            "code_line": "import random",
            "description": "We import the 'random' module to use its functions for generating random numbers."
          }
        },
        {
          "step_2": {
            "code_line": "number_to_guess = random.randint(0, 100)",
            "description": "We generate a random number between 0 and 100 that the user will try to guess."
          }
        },
        {
          "step_3": {
            "code_line": "guess = None",
            "description": "We initialize a variable 'guess' to track the user's current guess."
          }
        },
        {
          "step_4": {
            "code_line": "while guess != number_to_guess:",
            "description": "We start a loop that continues until the user guesses the correct number."
          }
        },
        {
          "step_5": {
            "code_line": "guess = int(input('Guess a number between 0 and 100: '))",
            "description": "We ask the user to input their guess and convert it to an integer."
          }
        },
        {
          "step_6": {
            "code_line": "if guess < number_to_guess:",
            "description": "We check if the guess is lower than the correct number and provide the hint 'GO UP'."
          }
        },
        {
          "step_7": {
            "code_line": "elif guess > number_to_guess:",
            "description": "We check if the guess is higher than the correct number and provide the hint 'GO DOWN'."
          }
        },
        {
          "step_8": {
            "code_line": "print('Congratulations! You guessed the number!')",
            "description": "Once the user guesses correctly, we congratulate them."
          }
        }
      ]
    }
  },
  "task_10": {
    "title": "New random number",
    "type": "practical",
    "description": "Write a function that takes an integer n and a list of (n-5) numbers, generating a random number between 0 and n-1 that is not in the list.",
    "explanation": {
      "beginner": {
        "title": "What Are We Doing?",
        "content": [
          {
            "tag": "concept",
            "text": "We'll create a function to find a random number that isn't included in the provided list."
          },
          {
            "tag": "action",
            "text": "You'll input a number n and a list of numbers, and the program will return a random number not in that list."
          },
          {
            "tag": "tool",
            "text": "We'll use the 'random' module to select a random number."
          }
        ]
      },
      "intermediate": {
        "title": "What's Happening Here?",
        "content": [
          {
            "tag": "goal",
            "text": "The function aims to generate a random number within a specified range while avoiding certain excluded numbers."
          },
          {
            "tag": "input_output",
            "text": "The user inputs a number n and a list, and the function checks for available numbers not in the list."
          },
          {
            "tag": "algorithm",
            "text": "We will create a range of numbers and filter out those present in the list before selecting randomly."
          }
        ]
      },
      "advanced": {
        "title": "Deep Dive",
        "content": [
          {
            "tag": "goal",
            "text": "Our objective is to demonstrate the use of random selection while managing exclusions."
          },
          {
            "tag": "methodology",
            "text": "We'll first generate a full range of potential numbers, then eliminate those present in the input list."
          },
          {
            "tag": "application",
            "text": "This technique can be useful in various scenarios where selections need to avoid specific values."
          }
        ]
      }
    },
    "solution": {
      "code": "import random\n\n# Step 1: Define the function to find a new random number\n\ndef new_random_number(n, excluded_numbers):\n    # Step 2: Create a set of all possible numbers\n    possible_numbers = set(range(n))\n    \n    # Step 3: Remove excluded numbers from the set\n    available_numbers = possible_numbers - set(excluded_numbers)\n    \n    # Step 4: Select a random number from available numbers\n    return random.choice(list(available_numbers))\n\n# Step 5: Get user input\nn = int(input('Enter n (n > 10): '))\nexcluded_numbers = list(map(int, input('Enter n-5 numbers: ').split()))\n\n# Step 6: Generate and print the new random number\nprint(new_random_number(n, excluded_numbers))",
      "steps": [
        {
          "step_1": {
            "code_line": "import random",
            "description": "We import the 'random' module to use its functions for generating random results."
          }
        },
        {
          "step_2": {
            "code_line": "def new_random_number(n, excluded_numbers):",
            "description": "We define a function that takes an integer n and a list of excluded numbers."
          }
        },
        {
          "step_3": {
            "code_line": "possible_numbers = set(range(n))",
            "description": "We create a set containing all numbers from 0 to n-1."
          }
        },
        {
          "step_4": {
            "code_line": "available_numbers = possible_numbers - set(excluded_numbers)",
            "description": "We filter out the excluded numbers, creating a set of available numbers."
          }
        },
        {
          "step_5": {
            "code_line": "return random.choice(list(available_numbers))",
            "description": "We select a random number from the available numbers and return it."
          }
        },
        {
          "step_6": {
            "code_line": "n = int(input('Enter n (n > 10): '))",
            "description": "We prompt the user to enter a number n, ensuring it's greater than 10."
          }
        },
        {
          "step_7": {
            "code_line": "excluded_numbers = list(map(int, input('Enter n-5 numbers: ').split()))",
            "description": "We take user input for the excluded numbers and convert it into a list of integers."
          }
        },
        {
          "step_8": {
            "code_line": "print(new_random_number(n, excluded_numbers))",
            "description": "We call the function with user inputs and print the generated random number."
          }
        }
      ]
    }
  },
  "task_11": {
    "title": "Random students group",
    "type": "practical",
    "description": "Write a program that reads the names of students and the number of groups to divide them into, then displays the formed groups.",
    "explanation": {
      "beginner": {
        "title": "What Are We Doing?",
        "content": [
          {
            "tag": "concept",
            "text": "We will take a list of student names and divide them into groups randomly."
          },
          {
            "tag": "action",
            "text": "You'll input the names of students and the number of groups, and the program will output the student groups."
          },
          {
            "tag": "tool",
            "text": "We'll use the 'random' module to shuffle the list of students."
          }
        ]
      },
      "intermediate": {
        "title": "What's Happening Here?",
        "content": [
          {
            "tag": "goal",
            "text": "We aim to distribute students into a specified number of groups evenly."
          },
          {
            "tag": "library",
            "text": "The 'random.shuffle' function allows us to randomly reorder the list of student names."
          },
          {
            "tag": "input_output",
            "text": "The user inputs student names and the number of groups, and the program will print the randomly assigned groups."
          }
        ]
      },
      "advanced": {
        "title": "Deep Dive",
        "content": [
          {
            "tag": "goal",
            "text": "Our objective is to demonstrate how to handle and manipulate lists to achieve a desired distribution."
          },
          {
            "tag": "methodology",
            "text": "We'll shuffle the list and then slice it into groups based on the number of groups specified."
          },
          {
            "tag": "application",
            "text": "This technique can be used in various scenarios, like organizing teams or allocating resources randomly."
          }
        ]
      }
    },
    "solution": {
      "code": "import random\n\n# Step 1: Get input from the user for student names and number of groups\nstudents = input('Enter the names of the students separated by spaces: ').split()\nn = int(input('Enter the number of groups (2 <= n <= students//2): '))\n\n# Step 2: Shuffle the list of students\nrandom.shuffle(students)\n\n# Step 3: Calculate the size of each group\ngroup_size = len(students) // n\n\n# Step 4: Create and display groups\nfor i in range(n):\n    group = students[i * group_size:(i + 1) * group_size]\n    print(' '.join(group))",
      "steps": [
        {
          "step_1": {
            "code_line": "import random",
            "description": "We import the 'random' module to use its functions for random operations."
          }
        },
        {
          "step_2": {
            "code_line": "students = input('Enter the names of the students separated by spaces: ').split()",
            "description": "We prompt the user to enter the names of students, split the input into a list of names."
          }
        },
        {
          "step_3": {
            "code_line": "n = int(input('Enter the number of groups (2 <= n <= students//2): '))",
            "description": "We ask the user for the number of groups and convert the input to an integer."
          }
        },
        {
          "step_4": {
            "code_line": "random.shuffle(students)",
            "description": "We randomly shuffle the list of student names to ensure groups are assigned randomly."
          }
        },
        {
          "step_5": {
            "code_line": "group_size = len(students) // n",
            "description": "We calculate the size of each group based on the total number of students divided by the number of groups."
          }
        },
        {
          "step_6": {
            "code_line": "for i in range(n):",
            "description": "We set up a loop to create the specified number of groups."
          }
        },
        {
          "step_7": {
            "code_line": "group = students[i * group_size:(i + 1) * group_size]",
            "description": "We slice the shuffled list to create each group of students."
          }
        },
        {
          "step_8": {
            "code_line": "print(' '.join(group))",
            "description": "We print the names in each group as a space-separated string."
          }
        }
      ]
    }
  },
  "task_12": {
    "title": "Random students group - II",
    "type": "practical",
    "description": "Write a program that reads the names of students and the number of groups to divide them into, then displays the formed groups, allowing for unequal distribution.",
    "explanation": {
      "beginner": {
        "title": "What Are We Doing?",
        "content": [
          {
            "tag": "concept",
            "text": "We will take a list of student names and divide them into groups randomly, even if they are not evenly distributed."
          },
          {
            "tag": "action",
            "text": "You'll input the names of students and the number of groups, and the program will output the student groups."
          },
          {
            "tag": "tool",
            "text": "We'll use the 'random' module to shuffle the list of students."
          }
        ]
      },
      "intermediate": {
        "title": "What's Happening Here?",
        "content": [
          {
            "tag": "goal",
            "text": "We want to distribute students into a specified number of groups without requiring equal sizes."
          },
          {
            "tag": "library",
            "text": "The 'random.shuffle' function allows us to randomly reorder the list of student names."
          },
          {
            "tag": "input_output",
            "text": "The user inputs student names and the number of groups, and the program will print the randomly assigned groups."
          }
        ]
      },
      "advanced": {
        "title": "Deep Dive",
        "content": [
          {
            "tag": "goal",
            "text": "Our objective is to demonstrate how to handle and manipulate lists to achieve a desired distribution."
          },
          {
            "tag": "methodology",
            "text": "We'll shuffle the list and then divide the students into groups, allowing the last group to potentially have fewer members."
          },
          {
            "tag": "application",
            "text": "This technique can be used in various scenarios, like organizing teams or allocating resources randomly."
          }
        ]
      }
    },
    "solution": {
      "code": "import random\n\n# Step 1: Get input from the user for student names and number of groups\nstudents = input('Enter the names of the students separated by spaces: ').split()\nn = int(input('Enter the number of groups (2 <= n <= students//2): '))\n\n# Step 2: Shuffle the list of students\nrandom.shuffle(students)\n\n# Step 3: Create and display groups\nfor i in range(n):\n    # Calculate the number of students in this group\n    group_size = len(students) // n + (1 if i < len(students) % n else 0)\n    group = students[:group_size]\n    print(' '.join(group))\n    # Remove the students in this group from the list\n    students = students[group_size:]",
      "steps": [
        {
          "step_1": {
            "code_line": "import random",
            "description": "We import the 'random' module to use its functions for random operations."
          }
        },
        {
          "step_2": {
            "code_line": "students = input('Enter the names of the students separated by spaces: ').split()",
            "description": "We prompt the user to enter the names of students and split the input into a list."
          }
        },
        {
          "step_3": {
            "code_line": "n = int(input('Enter the number of groups (2 <= n <= students//2): '))",
            "description": "We ask the user for the number of groups and convert the input to an integer."
          }
        },
        {
          "step_4": {
            "code_line": "random.shuffle(students)",
            "description": "We randomly shuffle the list of student names to ensure groups are assigned randomly."
          }
        },
        {
          "step_5": {
            "code_line": "for i in range(n):",
            "description": "We set up a loop to create the specified number of groups."
          }
        },
        {
          "step_6": {
            "code_line": "group_size = len(students) // n + (1 if i < len(students) % n else 0)",
            "description": "We calculate the size of this group, allowing for extra members in the first groups if not evenly divisible."
          }
        },
        {
          "step_7": {
            "code_line": "group = students[:group_size]",
            "description": "We slice the shuffled list to create the current group of students."
          }
        },
        {
          "step_8": {
            "code_line": "print(' '.join(group))",
            "description": "We print the names in the current group as a space-separated string."
          }
        },
        {
          "step_9": {
            "code_line": "students = students[group_size:]",
            "description": "We remove the students in the current group from the list for the next iteration."
          }
        }
      ]
    }
},
"task_13": {
    "title": "Random 2D",
    "type": "practical",
    "description": "Write a program to create a 5x5 array with random values between 0 and 100 and find the minimum and maximum values.",
    "explanation": {
      "beginner": {
        "title": "What Are We Doing?",
        "content": [
          {
            "tag": "concept",
            "text": "We will create a 5x5 grid filled with random numbers and determine the smallest and largest numbers in that grid."
          },
          {
            "tag": "action",
            "text": "The program will generate random numbers, fill the grid, and then find and display the min and max values."
          },
          {
            "tag": "tool",
            "text": "We'll use the 'random' module to generate random numbers."
          }
        ]
      },
      "intermediate": {
        "title": "What's Happening Here?",
        "content": [
          {
            "tag": "goal",
            "text": "We aim to create a two-dimensional list (array) and populate it with random numbers."
          },
          {
            "tag": "array_structure",
            "text": "A 5x5 array is essentially a list containing five lists, each with five random integers."
          },
          {
            "tag": "min_max",
            "text": "We will use built-in functions to determine the minimum and maximum values in the array."
          }
        ]
      },
      "advanced": {
        "title": "Deep Dive",
        "content": [
          {
            "tag": "goal",
            "text": "Our objective is to demonstrate the creation and manipulation of nested lists in Python."
          },
          {
            "tag": "random_values",
            "text": "We will generate random numbers using the 'random.randint' function to ensure we get values between 0 and 100."
          },
          {
            "tag": "further_usage",
            "text": "This approach can be extended to larger arrays or different data types, showcasing the versatility of lists."
          }
        ]
      }
    },
    "solution": {
      "code": "import random\n\n# Step 1: Create a 5x5 array with random values\narray_2d = [[random.randint(0, 100) for _ in range(5)] for _ in range(5)]\n\n# Step 2: Find the minimum and maximum values\nmin_value = min(min(row) for row in array_2d)\nmax_value = max(max(row) for row in array_2d)\n\n# Step 3: Print the results\nprint(array_2d)\nprint('Min:', min_value)\nprint('Max:', max_value)",
      "steps": [
        {
          "step_1": {
            "code_line": "import random",
            "description": "We import the 'random' module to use its functions for generating random numbers."
          }
        },
        {
          "step_2": {
            "code_line": "array_2d = [[random.randint(0, 100) for _ in range(5)] for _ in range(5)]",
            "description": "We create a 5x5 array, filling it with random integers between 0 and 100."
          }
        },
        {
          "step_3": {
            "code_line": "min_value = min(min(row) for row in array_2d)",
            "description": "We find the smallest number in the array by first finding the min in each row, then the overall min."
          }
        },
        {
          "step_4": {
            "code_line": "max_value = max(max(row) for row in array_2d)",
            "description": "Similarly, we find the largest number in the array."
          }
        },
        {
          "step_5": {
            "code_line": "print(array_2d)",
            "description": "We output the entire 2D array to see the randomly generated numbers."
          }
        },
        {
          "step_6": {
            "code_line": "print('Min:', min_value)",
            "description": "We print the minimum value found in the array."
          }
        },
        {
          "step_7": {
            "code_line": "print('Max:', max_value)",
            "description": "Finally, we print the maximum value found in the array."
          }
        }
      ]
    }
  },
  "task_14": {
    "title": "Math module",
    "type": "theoretical",
    "module": "math",
    "description": "Давайте вернемся к встроенному модулю math и посмотрим внимательнее на то, какие возможности он нам предоставляет.",
    "functions": {
      "factorial": {
        "description": "Мы писали программу для вычисления факториала числа, оказывается, такая функция уже есть.",
        "example": {
          "code": "import math\nprint(math.factorial(5))",
          "output": "120"
        }
      },
      "gcd": {
        "description": "Довольно часто применяется и функция gcd для нахождения наибольшего общего делителя.",
        "example": {
          "code": "import math\nprint(math.gcd(500, 600))",
          "output": "100"
        }
      },
      "pow": {
        "description": "Кроме того, есть функции для возведения в степень pow, которое принимает число, которое надо возвести в степень первым аргументом, а вторым аргументом — показатель степени.",
        "example": {
          "code": "import math\nprint(math.pow(10, 10))",
          "output": "10000000000.0"
        }
      },
      "sqrt": {
        "description": "А для извлечения квадратного корня числа есть функция math.sqrt.",
        "example": {
          "code": "import math\nprint(math.sqrt(16))",
          "output": "4.0"
        }
      },
      "trigonometric_functions": {
        "description": "В модуль math встроены тригонометрические функции вычисления синуса, косинуса, тангенса и т. д.",
        "examples": [
          {
            "code": "import math\nprint(math.sin(math.radians(90)))",
            "output": "1.0"
          },
          {
            "code": "import math\nprint(math.cos(math.radians(0)))",
            "output": "1.0"
          },
          {
            "code": "import math\nprint(math.tan(math.radians(45)))",
            "output": "0.9999999999999999"
          }
        ],
        "note": "Обратите внимание: они принимают на вход значение угла в радианах, поэтому данные в градусах надо перевести в радианы с помощью функции модуля math, которая называется radians. Существует и зеркальная функция degrees для перевода радиан в градусы."
      },
      "hypot": {
        "description": "Кроме того, math содержит ряд дополнительных интересных функций, например, знает теорему Пифагора.",
        "note": "Функция hypot(a, b) возвращает длину гипотенузы по двум катетам прямоугольного треугольника.",
        "reference": "Полный перечень функций и их описания можно посмотреть в документации."
      }
    }
  },
  "task_15": {
    "title": "pprint module",
    "type":"theoretical",
    "module": "pprint",
    "description": "Модуль pprint содержит функцию pprint, которую удобно использовать при выводе сложных типов данных. pprint старается вывести в консоль объекты в наиболее читабельном для человека виде. Ее особенно удобно использовать для вывода матриц.",
    "examples": [
      {
        "title": "Вывод матрицы",
        "code": [
          "import random",
          "from pprint import pprint",
          "a = [random.sample(range(20), 6) for _ in range(10)]",
          "print(a)",
          "print()",
          "pprint(a)"
        ],
        "output": [
          "[[0, 12, 14, 7, 15, 10], [8, 18, 15, 5, 13, 14], [15, 4, 14, 18, 17, 7],",
          " [11, 16, 19, 17, 14, 2], [6, 13, 8, 17, 9, 14], [15, 10, 4, 5, 17, 9],",
          " [16, 9, 14, 15, 13, 7], [12, 14, 9, 4, 7, 11], [13, 18, 12, 3, 17, 15],",
          " [5, 18, 16, 17, 9, 6]]",
          "",
          "[[0, 12, 14, 7, 15, 10],",
          " [8, 18, 15, 5, 13, 14],",
          " [15, 4, 14, 18, 17, 7],",
          " [11, 16, 19, 17, 14, 2],",
          " [6, 13, 8, 17, 9, 14],",
          " [15, 10, 4, 5, 17, 9],",
          " [16, 9, 14, 15, 13, 7],",
          " [12, 14, 9, 4, 7, 11],",
          " [13, 18, 12, 3, 17, 15],",
          " [5, 18, 16, 17, 9, 6]]"
        ]
      },
      {
        "title": "Вывод словаря",
        "code": [
          "from pprint import pprint",
          "b = {x: x ** 2 for x in range(20)}",
          "print(b)",
          "print()",
          "pprint(b)"
        ],
        "output": [
          "{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81,",
          " 10: 100, 11: 121, 12: 144, 13: 169, 14: 196, 15: 225, 16: 256,",
          " 17: 289, 18: 324, 19: 361}",
          "",
          "{0: 0,",
          " 1: 1,",
          " 2: 4,",
          " 3: 9,",
          " 4: 16,",
          " 5: 25,",
          " 6: 36,",
          " 7: 49,",
          " 8: 64,",
          " 9: 81,",
          " 10: 100,",
          " 11: 121,",
          " 12: 144,",
          " 13: 169,",
          " 14: 196,",
          " 15: 225,",
          " 16: 256,",
          " 17: 289,",
          " 18: 324,",
          " 19: 361}"
        ]
      }
    ]
  }
}
},

    "2": {
        "title": "PIL Library (Pillow)",
        "tasks": {
            "task_1": {
            "type": "theoretical",
            "title": "PIL Library (Pillow)",
            "description": "Understand the PIL library.",
            "learning_topic": "https://www.bzfar.org/publ/algorithms_programming/programming_languages/python_pil_library/42-1-0-201",
            "note": "Pillow is a powerful library that allows you to create and manipulate images in Python.",
            "key_features": [
                "Opening and saving images in various formats (JPEG, PNG, BMP, etc.)",
                "Creating new images and drawing on existing images",
                "Applying filters and transformations to images",
                "Working with image metadata"
            ],
            "common_methods": {
                "Image.open": "Opens an image file and returns an Image object.",
                "Image.save": "Saves the image to the specified file format.",
                "Image.show": "Displays the image in the default image viewer.",
                "Image.resize": "Resizes the image to the specified dimensions."
            },
            "examples": [
                {
                    "title": "Opening an Image",
                    "code": [
                        "from PIL import Image",
                        "image = Image.open('example.jpg')",
                        "image.show()"
                    ],
                    "output": "Displays the image 'example.jpg'."
                },
                {
                    "title": "Saving an Image",
                    "code": [
                        "image.save('output.png')"
                    ],
                    "output": "Saves the opened image as 'output.png'."
                }
            ],
            "reference": "For more detailed information, refer to the official Pillow documentation."
        },
    "task_2": {
      "title": "Create Rectangle",
      "type": "practical",
      "description": "Write a program to create a red rectangle in a *.jpg file with a size of 400x200 pixels.",
      "explanation": {
        "beginner": {
          "title": "What Are We Doing?",
          "content": [
            {
              "tag": "concept",
              "text": "We will create a red rectangle and save it as a JPEG image file."
            },
            {
              "tag": "action",
              "text": "The program will use the Pillow library to generate the image and draw the rectangle."
            },
            {
              "tag": "tool",
              "text": "We'll use the 'PIL' (Pillow) module to handle image creation."
            }
          ]
        },
        "intermediate": {
          "title": "What's Happening Here?",
          "content": [
            {
              "tag": "goal",
              "text": "Our goal is to use the Pillow library to create an image with a specific size and color."
            },
            {
              "tag": "image_structure",
              "text": "The image will be 400 pixels wide and 200 pixels tall, filled with red color."
            },
            {
              "tag": "file_format",
              "text": "We will save the image in JPEG format, which is commonly used for photographs."
            }
          ]
        },
        "advanced": {
          "title": "Deep Dive",
          "content": [
            {
              "tag": "image_creation",
              "text": "Using 'Image.new', we create a new image with the desired dimensions and color."
            },
            {
              "tag": "drawing_shapes",
              "text": "The 'ImageDraw' module allows us to draw shapes like rectangles on our image."
            },
            {
              "tag": "file_output",
              "text": "We will save the image using the 'save' method, specifying the file format."
            }
          ]
        }
      },
      "solution": {
        "code": "from PIL import Image, ImageDraw\n\n# Step 1: Create a new image with a red background\nimage = Image.new('RGB', (400, 200), 'red')\n\ndraw = ImageDraw.Draw(image)\n\n# Step 2: Save the image as a JPEG file\nimage.save('rectangle.jpg', 'JPEG')",
        "steps": [
          {
            "step_1": {
              "code_line": "from PIL import Image, ImageDraw",
              "description": "We import the necessary classes from the Pillow library to create and manipulate images."
            }
          },
          {
            "step_2": {
              "code_line": "image = Image.new('RGB', (400, 200), 'red')",
              "description": "We create a new image object with the specified size and red color."
            }
          },
          {
            "step_3": {
              "code_line": "draw = ImageDraw.Draw(image)",
              "description": "We create a drawing context to allow us to draw on the image."
            }
          },
          {
            "step_4": {
              "code_line": "image.save('rectangle.jpg', 'JPEG')",
              "description": "We save the created image as a JPEG file named 'rectangle.jpg'."
            }
          }
        ]
      }
    },
    "task_3": {
      "title": "Triangle",
      "type": "practical",
      "description": "Write a program to create a triangle in a *.jpg file. The triangle should fit within a screen size of 500x500 pixels.",
      "explanation": {
        "beginner": {
          "title": "What Are We Doing?",
          "content": [
            {
              "tag": "concept",
              "text": "We will create a triangle shape and save it as a JPEG image file."
            },
            {
              "tag": "action",
              "text": "The program will use the Pillow library to generate the image and draw the triangle."
            },
            {
              "tag": "tool",
              "text": "We'll use the 'PIL' (Pillow) module to handle image creation."
            }
          ]
        },
        "intermediate": {
          "title": "What's Happening Here?",
          "content": [
            {
              "tag": "goal",
              "text": "Our goal is to use the Pillow library to create an image with a specific size and draw a triangle."
            },
            {
              "tag": "image_structure",
              "text": "The image will be 500 pixels wide and 500 pixels tall, containing the triangle shape."
            },
            {
              "tag": "file_format",
              "text": "We will save the image in JPEG format, which is widely used for images."
            }
          ]
        },
        "advanced": {
          "title": "Deep Dive",
          "content": [
            {
              "tag": "triangle_creation",
              "text": "Using the 'polygon' method, we can draw a triangle by specifying its vertex coordinates."
            },
            {
              "tag": "image_creation",
              "text": "We will create a new image with a white background and draw the triangle on it."
            },
            {
              "tag": "file_output",
              "text": "We will save the image using the 'save' method, specifying the file format."
            }
          ]
        }
      },
      "solution": {
        "code": "from PIL import Image, ImageDraw\n\n# Step 1: Create a new image with a white background\nimage = Image.new('RGB', (500, 500), 'white')\n\ndraw = ImageDraw.Draw(image)\n\n# Step 2: Define the triangle vertices\ntriangle = [(250, 100), (100, 400), (400, 400)]\n\n# Step 3: Draw the triangle\ndraw.polygon(triangle, fill='blue')\n\n# Step 4: Save the image as a JPEG file\nimage.save('triangle.jpg', 'JPEG')",
        "steps": [
          {
            "step_1": {
              "code_line": "from PIL import Image, ImageDraw",
              "description": "We import the necessary classes from the Pillow library to create and manipulate images."
            }
          },
          {
            "step_2": {
              "code_line": "image = Image.new('RGB', (500, 500), 'white')",
              "description": "We create a new image object with the specified size and a white background."
            }
          },
          {
            "step_3": {
              "code_line": "triangle = [(250, 100), (100, 400), (400, 400)]",
              "description": "We define the vertices of the triangle using coordinates."
            }
          },
          {
            "step_4": {
              "code_line": "draw.polygon(triangle, fill='blue')",
              "description": "We draw the triangle shape on the image using the specified fill color."
            }
          },
          {
            "step_5": {
              "code_line": "image.save('triangle.jpg', 'JPEG')",
              "description": "We save the created image as a JPEG file named 'triangle.jpg'."
            }
          }
        ]
      }
    },
    "task_4": {
      "title": "Random Circle",
      "type": "practical",
      "description": "Write a program to create five circles with random placements in a *.jpg file. All circles should fit within a screen size of 400x500 pixels.",
      "explanation": {
        "beginner": {
          "title": "What Are We Doing?",
          "content": [
            {
              "tag": "concept",
              "text": "We will create five circles in random positions and save the image as a JPEG file."
            },
            {
              "tag": "action",
              "text": "The program will use the Pillow library to generate the image and draw the circles."
            },
            {
              "tag": "tool",
              "text": "We'll use the 'PIL' (Pillow) module to handle image creation."
            }
          ]
        },
        "intermediate": {
          "title": "What's Happening Here?",
          "content": [
            {
              "tag": "goal",
              "text": "Our goal is to use the Pillow library to create an image and draw circles in random locations."
            },
            {
              "tag": "image_structure",
              "text": "The image will be 400 pixels wide and 500 pixels tall, containing five circles."
            },
            {
              "tag": "random_colors",
              "text": "Each circle will have a random color, determined by generating random RGB values."
            }
          ]
        },
        "advanced": {
          "title": "Deep Dive",
          "content": [
            {
              "tag": "random_positions",
              "text": "We will generate random positions for each circle using the 'randint' function."
            },
            {
              "tag": "circle_drawing",
              "text": "The 'ellipse' method will be used to draw each circle, specified by bounding box coordinates."
            },
            {
              "tag": "file_output",
              "text": "We will save the image using the 'save' method, specifying the file format."
            }
          ]
        }
      },
      "solution": {
        "code": "from PIL import Image, ImageDraw\nimport random as r\n\nnew_image = Image.new('RGB', (400, 500), (255, 255, 255))\ndraw = ImageDraw.Draw(new_image)\ncircle_size = 50\na, b = 0, 255\n\nfor _ in range(5):\n    x = r.randint(circle_size, 400 - circle_size)\n    y = r.randint(circle_size, 500 - circle_size)\n    draw.ellipse((x - circle_size, y - circle_size, x + circle_size, y + circle_size), fill=(r.randint(a, b), r.randint(a, b), r.randint(a, b)))\n\nnew_image.save('output_image.png')\nnew_image.show()",
        "steps": [
          {
            "step_1": {
              "code_line": "from PIL import Image, ImageDraw",
              "description": "We import the necessary classes from the Pillow library to create and manipulate images."
            }
          },
          {
            "step_2": {
              "code_line": "import random as r",
              "description": "We import the 'random' module to generate random numbers for circle positions and colors."
            }
          },
          {
            "step_3": {
              "code_line": "new_image = Image.new('RGB', (400, 500), (255, 255, 255))",
              "description": "We create a new image object with the specified size and a white background."
            }
          },
          {
            "step_4": {
              "code_line": "draw = ImageDraw.Draw(new_image)",
              "description": "We create a drawing context to allow us to draw on the image."
            }
          },
          {
            "step_5": {
              "code_line": "circle_size = 50",
              "description": "We define the size of the circles to be drawn."
            }
          },
          {
            "step_6": {
              "code_line": "for _ in range(5):",
              "description": "We loop five times to create five circles."
            }
          },
          {
            "step_7": {
              "code_line": "x = r.randint(circle_size, 400 - circle_size)",
              "description": "We generate a random x-coordinate for the circle's center, ensuring it fits within the image bounds."
            }
          },
          {
            "step_8": {
              "code_line": "y = r.randint(circle_size, 500 - circle_size)",
              "description": "We generate a random y-coordinate for the circle's center."
            }
          },
          {
            "step_9": {
              "code_line": "draw.ellipse((x - circle_size, y - circle_size, x + circle_size, y + circle_size), fill=(r.randint(a, b), r.randint(a, b), r.randint(a, b)))",
              "description": "We draw the circle at the generated position with a random fill color."
            }
          },
          {
            "step_10": {
              "code_line": "new_image.save('output_image.png')",
              "description": "We save the created image as a PNG file named 'output_image.png'."
            }
          },
          {
            "step_11": {
              "code_line": "new_image.show()",
              "description": "We display the created image."
            }
          }
        ]
      }
    },
    "task_5": {
      "title": "Half Moon",
      "type": "practical",
      "description": "Write a program to create a half moon shape in a *.jpg file.",
      "explanation": {
        "beginner": {
          "title": "What Are We Doing?",
          "content": [
            {
              "tag": "concept",
              "text": "We will create a half moon shape by combining two circles."
            },
            {
              "tag": "action",
              "text": "The program will use the Pillow library to generate the image and draw the shapes."
            },
            {
              "tag": "tool",
              "text": "We'll use the 'PIL' (Pillow) module to handle image creation."
            }
          ]
        },
        "intermediate": {
          "title": "What's Happening Here?",
          "content": [
            {
              "tag": "goal",
              "text": "Our goal is to draw a yellow circle and cut out part of it to create the half moon effect."
            },
            {
              "tag": "image_structure",
              "text": "The image will be 400 pixels wide and 400 pixels tall, containing the half moon shape."
            },
            {
              "tag": "color_use",
              "text": "We will use yellow for the full circle and white for the circle that cuts out the half moon."
            }
          ]
        },
        "advanced": {
          "title": "Deep Dive",
          "content": [
            {
              "tag": "circle_drawing",
              "text": "We will use the 'ellipse' method to draw the full circle and the circle to cut out the half moon."
            },
            {
              "tag": "shape_manipulation",
              "text": "By overlapping circles, we create the desired half moon shape."
            },
            {
              "tag": "file_output",
              "text": "We will save the image using the 'save' method, specifying the file format."
            }
          ]
        }
      },
      "solution": {
        "code": "from PIL import Image, ImageDraw\n\n# Create a blank white image\nwidth, height = 400, 400\nimage = Image.new('RGB', (width, height), 'white')\n\n# Create a drawing context\ndraw = ImageDraw.Draw(image)\n\n# Draw a yellow full circle\ndraw.ellipse([50, 50, 350, 350], fill='yellow')\n\n# Draw a white circle to cut out the half moon shape\ndraw.ellipse([150, 50, 450, 350], fill='white')\n\n# Save the result\nimage.save('half_moon.jpg')\n\n# To display the image in a Jupyter notebook or Python environment\nimage.show()",
        "steps": [
          {
            "step_1": {
              "code_line": "from PIL import Image, ImageDraw",
              "description": "We import the necessary classes from the Pillow library to create and manipulate images."
            }
          },
          {
            "step_2": {
              "code_line": "width, height = 400, 400",
              "description": "We define the dimensions of the image, which will be 400x400 pixels."
            }
          },
          {
            "step_3": {
              "code_line": "image = Image.new('RGB', (width, height), 'white')",
              "description": "We create a new blank image with a white background."
            }
          },
          {
            "step_4": {
              "code_line": "draw = ImageDraw.Draw(image)",
              "description": "We create a drawing context that allows us to draw on the image."
            }
          },
          {
            "step_5": {
              "code_line": "draw.ellipse([50, 50, 350, 350], fill='yellow')",
              "description": "We draw a yellow full circle using the 'ellipse' method."
            }
          },
          {
            "step_6": {
              "code_line": "draw.ellipse([150, 50, 450, 350], fill='white')",
              "description": "We draw a white circle that overlaps with the yellow circle to create the half moon shape."
            }
          },
          {
            "step_7": {
              "code_line": "image.save('half_moon.jpg')",
              "description": "We save the created image as a JPEG file named 'half_moon.jpg'."
            }
          },
          {
            "step_8": {
              "code_line": "image.show()",
              "description": "We display the created image."
            }
          }
        ]
      }
    },
  "task_6": {
    "title": "Fence",
    "type": "practical",
    "description": "Write a program to create a function to draw a fence in a *.jpg file using a loop.",
    "explanation": {
      "beginner": {
        "title": "What Are We Doing?",
        "content": [
          {
            "tag": "concept",
            "text": "We will create a fence using rectangles for the posts and triangles for the tops."
          },
          {
            "tag": "action",
            "text": "The program will draw multiple fence posts in a row, using a loop to create them."
          },
          {
            "tag": "tool",
            "text": "We'll use the Pillow library to generate the image and draw shapes."
          }
        ]
      },
      "intermediate": {
        "title": "What's Happening Here?",
        "content": [
          {
            "tag": "goal",
            "text": "Our goal is to create a visual representation of a fence using basic geometric shapes."
          },
          {
            "tag": "loop_usage",
            "text": "We'll use a loop to repeat the drawing of the fence posts, ensuring uniform spacing."
          },
          {
            "tag": "color_choice",
            "text": "The fence posts will be drawn in brown to represent a realistic wooden fence."
          }
        ]
      },
      "advanced": {
        "title": "Deep Dive",
        "content": [
          {
            "tag": "function_creation",
            "text": "We define a function that encapsulates the drawing logic for reusability."
          },
          {
            "tag": "geometry",
            "text": "We utilize rectangles for the posts and triangles for the tops, leveraging Pillow's drawing capabilities."
          },
          {
            "tag": "image_output",
            "text": "The created image will be saved as 'fence.jpg' for visual inspection."
          }
        ]
      }
    },
    "solution": {
      "code": "from PIL import Image, ImageDraw\n\ndef draw_fence():\n    # Create a blank white image\n    width, height = 800, 300\n    image = Image.new('RGB', (width, height), 'white')\n    \n    # Create a drawing context\n    draw = ImageDraw.Draw(image)\n    \n    # Define fence parameters\n    post_width = 60\n    post_height = 200\n    space_between = 10\n    post_color = (150, 75, 0)  # brown color\n    \n    # Draw the fence using a loop\n    for i in range(10):  # We need 10 fence posts\n        x0 = i * (post_width + space_between) + 20\n        y0 = height - post_height\n        x1 = x0 + post_width\n        y1 = height\n        \n        # Draw the rectangle for the post\n        draw.rectangle([x0, y0, x1, y1], fill=post_color)\n        \n        # Draw the triangle for the top of the post\n        draw.polygon([(x0, y0), ((x0 + x1) // 2, y0 - 50), (x1, y0)], fill=post_color)\n    \n    # Save the result\n    image.save('fence.jpg')\n    \n    # Show the image (for local testing)\n    image.show()\n\n# Call the function to draw the fence\ndraw_fence()",
      "steps": [
        {
          "step_1": {
            "code_line": "from PIL import Image, ImageDraw",
            "description": "We import the necessary classes from the Pillow library to create and manipulate images."
          }
        },
        {
          "step_2": {
            "code_line": "def draw_fence():",
            "description": "We define a function named 'draw_fence' that will encapsulate the fence drawing logic."
          }
        },
        {
          "step_3": {
            "code_line": "width, height = 800, 300",
            "description": "We set the dimensions of the image to be 800 pixels wide and 300 pixels tall."
          }
        },
        {
          "step_4": {
            "code_line": "image = Image.new('RGB', (width, height), 'white')",
            "description": "We create a new blank image with a white background."
          }
        },
        {
          "step_5": {
            "code_line": "draw = ImageDraw.Draw(image)",
            "description": "We create a drawing context that allows us to draw on the image."
          }
        },
        {
          "step_6": {
            "code_line": "for i in range(10):",
            "description": "We start a loop to draw 10 fence posts, ensuring uniform spacing."
          }
        },
        {
          "step_7": {
            "code_line": "draw.rectangle([x0, y0, x1, y1], fill=post_color)",
            "description": "We draw a rectangle for each fence post, filling it with the defined brown color."
          }
        },
        {
          "step_8": {
            "code_line": "draw.polygon([(x0, y0), ((x0 + x1) // 2, y0 - 50), (x1, y0)], fill=post_color)",
            "description": "We draw a triangle on top of each post to complete the fence design."
          }
        },
        {
          "step_9": {
            "code_line": "image.save('fence.jpg')",
            "description": "We save the created image as a JPEG file named 'fence.jpg'."
          }
        },
        {
          "step_10": {
            "code_line": "image.show()",
            "description": "We display the created image for visual inspection."
          }
        }
      ]
    }
  },
  "task_7": {
    "title": "House",
    "type": "practical",
    "description": "Write a program to create a picture of a house in a *.jpg file according to the provided design.",
    "explanation": {
      "beginner": {
        "title": "What Are We Doing?",
        "content": [
          {
            "tag": "concept",
            "text": "We will create a picture of a house using rectangles and triangles to represent the body and roof."
          },
          {
            "tag": "action",
            "text": "The program will draw the house, a window, and a sun with rays."
          },
          {
            "tag": "tool",
            "text": "We'll use the Pillow library for image creation and drawing."
          }
        ]
      },
      "intermediate": {
        "title": "What's Happening Here?",
        "content": [
          {
            "tag": "goal",
            "text": "Our goal is to draw various shapes to form a complete house with a window and sun."
          },
          {
            "tag": "shape_usage",
            "text": "We will use rectangles for the house body and window, a triangle for the roof, and a circle for the sun."
          },
          {
            "tag": "color_choice",
            "text": "Different colors will be used to make the house visually appealing."
          }
        ]
      },
      "advanced": {
        "title": "Deep Dive",
        "content": [
          {
            "tag": "function_creation",
            "text": "We define a function 'draw_house' to encapsulate the drawing logic for reusability."
          },
          {
            "tag": "math_usage",
            "text": "We use trigonometry to calculate the positions of the sun rays around the sun."
          },
          {
            "tag": "image_output",
            "text": "The created image will be saved as 'house.jpg' for visual inspection."
          }
        ]
      }
    },
    "solution": {
      "code": "from PIL import Image, ImageDraw\nimport math\n\ndef draw_house():\n    # Create a blank white image\n    width, height = 600, 400\n    image = Image.new('RGB', (width, height), 'white')\n    \n    # Create a drawing context\n    draw = ImageDraw.Draw(image)\n    \n    # Draw the house body (blue rectangle)\n    house_color = (0, 0, 255)  # blue\n    draw.rectangle([150, 200, 450, 350], fill=house_color)\n    \n    # Draw the roof (green triangle)\n    roof_color = (0, 255, 0)  # green\n    draw.polygon([(150, 200), (300, 100), (450, 200)], fill=roof_color)\n    \n    # Draw the window (white square with brown cross)\n    window_color = (255, 255, 255)  # white\n    cross_color = (150, 75, 0)  # brown\n    draw.rectangle([275, 250, 325, 300], fill=window_color)  # white square\n    # Draw the cross on the window\n    draw.line([275, 275, 325, 275], fill=cross_color, width=5)  # horizontal line\n    draw.line([300, 250, 300, 300], fill=cross_color, width=5)  # vertical line\n    \n    # Draw the sun (yellow circle with rays)\n    sun_color = (255, 255, 0)  # yellow\n    draw.ellipse([450, 50, 520, 120], fill=sun_color)  # sun circle\n    # Draw sun rays\n    for i in range(8):\n        angle = i * 45  # degrees for ray positions\n        start_x = 485 + 50 * round(math.cos(math.radians(angle)))\n        start_y = 85 + 50 * round(math.sin(math.radians(angle)))\n        end_x = 485 + 70 * round(math.cos(math.radians(angle)))\n        end_y = 85 + 70 * round(math.sin(math.radians(angle)))\n        draw.line([start_x, start_y, end_x, end_y], fill=sun_color, width=3)\n    \n    # Save the result\n    image.save('house.jpg')\n    \n    # Show the image (for local testing)\n    image.show()\n\n# Call the function to draw the house\ndraw_house()",
      "steps": [
        {
          "step_1": {
            "code_line": "from PIL import Image, ImageDraw",
            "description": "We import the necessary classes from the Pillow library to create and manipulate images."
          }
        },
        {
          "step_2": {
            "code_line": "import math",
            "description": "We import the math module to use trigonometric functions for sun ray calculations."
          }
        },
        {
          "step_3": {
            "code_line": "def draw_house():",
            "description": "We define a function named 'draw_house' that encapsulates the drawing logic."
          }
        },
        {
          "step_4": {
            "code_line": "image = Image.new('RGB', (width, height), 'white')",
            "description": "We create a new blank image with a white background."
          }
        },
        {
          "step_5": {
            "code_line": "draw.rectangle([150, 200, 450, 350], fill=house_color)",
            "description": "We draw the house body as a blue rectangle."
          }
        },
        {
          "step_6": {
            "code_line": "draw.polygon([(150, 200), (300, 100), (450, 200)], fill=roof_color)",
            "description": "We draw the roof as a green triangle on top of the house."
          }
        },
        {
          "step_7": {
            "code_line": "draw.rectangle([275, 250, 325, 300], fill=window_color)",
            "description": "We draw a white square for the window."
          }
        },
        {
          "step_8": {
            "code_line": "draw.line([275, 275, 325, 275], fill=cross_color, width=5)",
            "description": "We draw a horizontal brown line to create a cross in the window."
          }
        },
        {
          "step_9": {
            "code_line": "draw.ellipse([450, 50, 520, 120], fill=sun_color)",
            "description": "We draw the sun as a yellow circle."
          }
        },
        {
          "step_10": {
            "code_line": "draw.line([start_x, start_y, end_x, end_y], fill=sun_color, width=3)",
            "description": "We draw sun rays extending from the circle using trigonometric calculations."
          }
        },
        {
          "step_11": {
            "code_line": "image.save('house.jpg')",
            "description": "We save the created image as 'house.jpg' for visual inspection."
          }
        },
        {
          "step_12": {
            "code_line": "image.show()",
            "description": "We display the created image."
          }
        }
      ]
    }
  },
  "task_8": {
    "title": "Free art",
    "type": "practical",
    "description": "Create your own picture using at least four different graphical primitives. Be creative in your work.",
    "explanation": {
      "beginner": {
        "title": "What Are We Doing?",
        "content": [
          {
            "tag": "concept",
            "text": "We will create an original piece of art using various shapes like rectangles, circles, and lines."
          },
          {
            "tag": "action",
            "text": "The program will allow for creative expression by combining different graphical elements."
          },
          {
            "tag": "tool",
            "text": "We'll use the Pillow library to draw on a canvas."
          }
        ]
      },
      "intermediate": {
        "title": "What's Happening Here?",
        "content": [
          {
            "tag": "goal",
            "text": "Our goal is to combine at least four shapes to create a visually interesting image."
          },
          {
            "tag": "shape_usage",
            "text": "We'll experiment with various shapes like rectangles, ellipses, arcs, and lines."
          },
          {
            "tag": "color_choice",
            "text": "Different colors will be used to enhance the visual appeal of the artwork."
          }
        ]
      },
      "advanced": {
        "title": "Deep Dive",
        "content": [
          {
            "tag": "function_creation",
            "text": "We define a function to encapsulate the drawing logic for reusability."
          },
          {
            "tag": "creative_exploration",
            "text": "We explore how different shapes can interact and complement each other visually."
          },
          {
            "tag": "image_output",
            "text": "The created image will be saved for display and further evaluation."
          }
        ]
      }
    },
    "solution": {
      "code": "from PIL import Image, ImageDraw\n\n\ndef draw_free_art():\n    # Create a blank canvas\n    width, height = 600, 600\n    image = Image.new('RGB', (width, height), 'white')\n    draw = ImageDraw.Draw(image)\n\n    # Draw a rectangle\n    draw.rectangle([50, 50, 250, 250], fill='blue')\n\n    # Draw a circle\n    draw.ellipse([350, 50, 550, 250], fill='red')\n\n    # Draw a line\n    draw.line([0, 600, 600, 0], fill='green', width=5)\n\n    # Draw an arc\n    draw.arc([100, 300, 500, 600], start=0, end=180, fill='yellow', width=10)\n\n    # Save and display the image\n    image.save('free_art.jpg')\n    image.show()\n\n# Run the function to draw the free art image\ndraw_free_art()",
      "steps": [
        {
          "step_1": {
            "code_line": "from PIL import Image, ImageDraw",
            "description": "We import the necessary classes from the Pillow library to create and manipulate images."
          }
        },
        {
          "step_2": {
            "code_line": "def draw_free_art():",
            "description": "We define a function named 'draw_free_art' to encapsulate the drawing logic."
          }
        },
        {
          "step_3": {
            "code_line": "image = Image.new('RGB', (width, height), 'white')",
            "description": "We create a new blank image with a white background."
          }
        },
        {
          "step_4": {
            "code_line": "draw.rectangle([50, 50, 250, 250], fill='blue')",
            "description": "We draw a blue rectangle as one of our graphical primitives."
          }
        },
        {
          "step_5": {
            "code_line": "draw.ellipse([350, 50, 550, 250], fill='red')",
            "description": "We draw a red circle as another graphical primitive."
          }
        },
        {
          "step_6": {
            "code_line": "draw.line([0, 600, 600, 0], fill='green', width=5)",
            "description": "We draw a green diagonal line to add variety."
          }
        },
        {
          "step_7": {
            "code_line": "draw.arc([100, 300, 500, 600], start=0, end=180, fill='yellow', width=10)",
            "description": "We draw a yellow arc to further diversify our artwork."
          }
        },
        {
          "step_8": {
            "code_line": "image.save('free_art.jpg')",
            "description": "We save the created image as 'free_art.jpg' for visual inspection."
          }
        },
        {
          "step_9": {
            "code_line": "image.show()",
            "description": "We display the created image."
          }
        }
      ]
    }
  },
  "task_9": {
    "title": "Source picture",
    "type": "practical",
    "description": "Open an image file and save a copy of the image into a new file.",
    "explanation": {
      "beginner": {
        "title": "What Are We Doing?",
        "content": [
          {
            "tag": "concept",
            "text": "We will open an existing image file and create a copy of it."
          },
          {
            "tag": "action",
            "text": "The program will read the image and save it under a new name."
          },
          {
            "tag": "tool",
            "text": "We'll use the Pillow library to handle image operations."
          }
        ]
      },
      "intermediate": {
        "title": "What's Happening Here?",
        "content": [
          {
            "tag": "goal",
            "text": "Our goal is to manipulate image files by copying them."
          },
          {
            "tag": "file_handling",
            "text": "We will learn how to load and save image files using Pillow."
          },
          {
            "tag": "path_management",
            "text": "File paths will be important to specify where the image is located and where to save the copy."
          }
        ]
      },
      "advanced": {
        "title": "Deep Dive",
        "content": [
          {
            "tag": "image_processing",
            "text": "We explore the underlying functions of the Pillow library for efficient image handling."
          },
          {
            "tag": "error_handling",
            "text": "We may consider adding error handling for cases where the image file might not exist."
          },
          {
            "tag": "image_format",
            "text": "Different formats may affect how the image is saved and should be considered."
          }
        ]
      }
    },
    "solution": {
      "code": "from PIL import Image\n\n# Load the image\nimg_path = '/mnt/data/image.png'\nimg = Image.open(img_path)\n\n# Save a copy of the image\nimg.save('/mnt/data/copied_image.png')\n\nprint('Image has been copied successfully!')",
      "steps": [
        {
          "step_1": {
            "code_line": "from PIL import Image",
            "description": "We import the Image class from the Pillow library to work with images."
          }
        },
        {
          "step_2": {
            "code_line": "img_path = '/mnt/data/image.png'",
            "description": "We specify the path of the image we want to open."
          }
        },
        {
          "step_3": {
            "code_line": "img = Image.open(img_path)",
            "description": "We open the image file and load it into the program."
          }
        },
        {
          "step_4": {
            "code_line": "img.save('/mnt/data/copied_image.png')",
            "description": "We save a copy of the opened image under a new name."
          }
        },
        {
          "step_5": {
            "code_line": "print('Image has been copied successfully!')",
            "description": "We print a confirmation message to indicate the operation was successful."
          }
        }
      ]
    }
  },
  "task_10": {
    "title": "Red channel",
    "type": "practical",
    "description": "Edit a picture to keep only the red channel, replacing the green and blue channels with 0.",
    "explanation": {
      "beginner": {
        "title": "What Are We Doing?",
        "content": [
          {
            "tag": "concept",
            "text": "We will isolate the red channel of an image and set the other channels to zero."
          },
          {
            "tag": "action",
            "text": "The program will open an image, manipulate the color channels, and save the result."
          },
          {
            "tag": "tool",
            "text": "We'll use the Pillow library to work with the image channels."
          }
        ]
      },
      "intermediate": {
        "title": "What's Happening Here?",
        "content": [
          {
            "tag": "goal",
            "text": "Our goal is to understand how to manipulate color channels in images."
          },
          {
            "tag": "channel_manipulation",
            "text": "We will learn how to split an image into its RGB components and merge them back."
          },
          {
            "tag": "image_processing",
            "text": "The green and blue channels will be modified to create the desired effect."
          }
        ]
      },
      "advanced": {
        "title": "Deep Dive",
        "content": [
          {
            "tag": "channel_operations",
            "text": "We will explore the underlying operations for channel manipulation in Pillow."
          },
          {
            "tag": "lambda_function",
            "text": "Using lambda functions to modify pixel values allows for flexible channel manipulation."
          },
          {
            "tag": "performance_considerations",
            "text": "When dealing with large images, performance and memory usage should be considered."
          }
        ]
      }
    },
    "solution": {
      "code": "from PIL import Image\n\n# Open the image\nimg_path = '/mnt/data/image.png'\nimg = Image.open(img_path)\n\n# Split the image into red, green, and blue channels\nr, g, b = img.split()\n\n# Create a new image with only the red channel (green and blue channels set to 0)\nred_img = Image.merge('RGB', (r, g.point(lambda _: 0), b.point(lambda _: 0)))\n\n# Save the modified image\nred_img.save('/mnt/data/red_channel_image.png')\n\nprint('Image with only red channel has been saved successfully!')",
      "steps": [
        {
          "step_1": {
            "code_line": "from PIL import Image",
            "description": "We import the Image class from the Pillow library to work with images."
          }
        },
        {
          "step_2": {
            "code_line": "img_path = '/mnt/data/image.png'",
            "description": "We specify the path of the image we want to open."
          }
        },
        {
          "step_3": {
            "code_line": "img = Image.open(img_path)",
            "description": "We open the image file and load it into the program."
          }
        },
        {
          "step_4": {
            "code_line": "r, g, b = img.split()",
            "description": "We split the image into its red, green, and blue channels."
          }
        },
        {
          "step_5": {
            "code_line": "red_img = Image.merge('RGB', (r, g.point(lambda _: 0), b.point(lambda _: 0)))",
            "description": "We create a new image using the red channel and set green and blue channels to 0."
          }
        },
        {
          "step_6": {
            "code_line": "red_img.save('/mnt/data/red_channel_image.png')",
            "description": "We save the modified image under a new name."
          }
        },
        {
          "step_7": {
            "code_line": "print('Image with only red channel has been saved successfully!')",
            "description": "We print a confirmation message to indicate the operation was successful."
          }
        }
      ]
    }
  },
  "task_11": {
    "title": "Black and white image",
    "type": "practical",
    "description": "Convert any image to black-and-white using the formula (R + G + B) / 3.",
    "explanation": {
      "beginner": {
        "title": "What Are We Doing?",
        "content": [
          {
            "tag": "concept",
            "text": "We will transform a color image into a black-and-white image."
          },
          {
            "tag": "action",
            "text": "The program will read an image, convert each pixel, and save the new image."
          },
          {
            "tag": "tool",
            "text": "We'll use the Pillow library to manipulate the image."
          }
        ]
      },
      "intermediate": {
        "title": "What's Happening Here?",
        "content": [
          {
            "tag": "goal",
            "text": "Our goal is to learn how to manipulate pixel data in an image."
          },
          {
            "tag": "grayscale_conversion",
            "text": "We will convert each pixel to grayscale using a simple formula."
          },
          {
            "tag": "pixel_processing",
            "text": "The pixel manipulation involves accessing and modifying RGB values."
          }
        ]
      },
      "advanced": {
        "title": "Deep Dive",
        "content": [
          {
            "tag": "pixel_iteration",
            "text": "We will iterate through each pixel to apply the grayscale formula."
          },
          {
            "tag": "color_model",
            "text": "Understanding how RGB values represent colors will help in manipulation."
          },
          {
            "tag": "performance_considerations",
            "text": "Efficiency can be improved by using vectorized operations or external libraries."
          }
        ]
      }
    },
    "solution": {
      "code": "from PIL import Image\n\n# Open the image\nimg_path = '/mnt/data/image.png'\nimg = Image.open(img_path)\n\n# Load the pixel data\npixels = img.load()\n\n# Get image dimensions\nwidth, height = img.size\n\n# Iterate over each pixel and apply the formula\nfor x in range(width):\n    for y in range(height):\n        r, g, b = pixels[x, y]\n        # Calculate the grayscale value using the formula (R + G + B) / 3\n        gray = int((r + g + b) / 3)\n        # Set the new pixel value (gray for all channels)\n        pixels[x, y] = (gray, gray, gray)\n\n# Save the modified image\nimg.save('/mnt/data/black_and_white_image_custom_formula.png')\n\nprint('Black-and-white image using the formula has been saved successfully!')",
      "steps": [
        {
          "step_1": {
            "code_line": "from PIL import Image",
            "description": "We import the Image class from the Pillow library to work with images."
          }
        },
        {
          "step_2": {
            "code_line": "img_path = '/mnt/data/image.png'",
            "description": "We specify the path of the image we want to convert."
          }
        },
        {
          "step_3": {
            "code_line": "img = Image.open(img_path)",
            "description": "We open the image file and load it into the program."
          }
        },
        {
          "step_4": {
            "code_line": "pixels = img.load()",
            "description": "We load the pixel data for manipulation."
          }
        },
        {
          "step_5": {
            "code_line": "width, height = img.size",
            "description": "We retrieve the dimensions of the image."
          }
        },
        {
          "step_6": {
            "code_line": "for x in range(width):\n    for y in range(height):",
            "description": "We iterate over each pixel in the image."
          }
        },
        {
          "step_7": {
            "code_line": "r, g, b = pixels[x, y]",
            "description": "We extract the RGB values for the current pixel."
          }
        },
        {
          "step_8": {
            "code_line": "gray = int((r + g + b) / 3)",
            "description": "We calculate the grayscale value by averaging the RGB components."
          }
        },
        {
          "step_9": {
            "code_line": "pixels[x, y] = (gray, gray, gray)",
            "description": "We set the new pixel value to the calculated grayscale."
          }
        },
        {
          "step_10": {
            "code_line": "img.save('/mnt/data/black_and_white_image_custom_formula.png')",
            "description": "We save the modified black-and-white image under a new name."
          }
        },
        {
          "step_11": {
            "code_line": "print('Black-and-white image using the formula has been saved successfully!')",
            "description": "We print a confirmation message to indicate the operation was successful."
          }
        }
      ]
    }
  },
  "task_12": {
    "title": "Opposite color",
    "type": "practical",
    "description": "Given a color in RGB format, return the opposite color using the formula (255 - R)(255 - G)(255 - B), where R, G, and B are the intensities of the red, green, and blue components of the color.",
    "explanation": {
      "beginner": {
        "title": "What Are We Doing?",
        "content": [
          {
            "tag": "concept",
            "text": "We are going to find the opposite color of a given color by subtracting the RGB values from 255."
          },
          {
            "tag": "action",
            "text": "The program will read the input color values and compute the opposite color."
          },
          {
            "tag": "tool",
            "text": "We'll use the PIL library to work with RGB values and manipulate colors."
          }
        ]
      },
      "intermediate": {
        "title": "What's Happening Here?",
        "content": [
          {
            "tag": "goal",
            "text": "Our goal is to explore how RGB values can be manipulated to find complementary or opposite colors."
          },
          {
            "tag": "color_complement",
            "text": "By subtracting each color component from 255, we generate a harmonious opposite color."
          },
          {
            "tag": "user_input",
            "text": "The program takes RGB values as input and outputs the computed opposite RGB values."
          }
        ]
      },
      "advanced": {
        "title": "Deep Dive",
        "content": [
          {
            "tag": "rgb_model",
            "text": "Understanding the RGB color model helps us better comprehend color manipulations like opposites and complements."
          },
          {
            "tag": "color_harmony",
            "text": "Opposite colors in design and visual arts are known to create visually harmonious effects."
          },
          {
            "tag": "further_exploration",
            "text": "Beyond RGB, we can explore other color models (such as HSL or CMYK) for color transformations."
          }
        ]
      }
    },
    "solution": {
      "code": "from PIL import ImageColor\n\ndef opposite_color(r, g, b):\n    opposite_r = 255 - r\n    opposite_g = 255 - g\n    opposite_b = 255 - b\n    return opposite_r, opposite_g, opposite_b\n\ninput_color = input()\nr, g, b = map(int, input_color.split())\n\nopposite_r, opposite_g, opposite_b = opposite_color(r, g, b)\n\nprint(opposite_r, opposite_g, opposite_b)",
      "steps": [
        {
          "step_1": {
            "code_line": "from PIL import ImageColor",
            "description": "We import the necessary module to work with colors in RGB."
          }
        },
        {
          "step_2": {
            "code_line": "def opposite_color(r, g, b):",
            "description": "We define a function to calculate the opposite color using the formula (255 - R, 255 - G, 255 - B)."
          }
        },
        {
          "step_3": {
            "code_line": "opposite_r = 255 - r\nopposite_g = 255 - g\nopposite_b = 255 - b",
            "description": "We subtract the input RGB values from 255 to find the opposite color components."
          }
        },
        {
          "step_4": {
            "code_line": "return opposite_r, opposite_g, opposite_b",
            "description": "We return the opposite RGB values."
          }
        },
        {
          "step_5": {
            "code_line": "input_color = input()",
            "description": "We receive user input as space-separated RGB values."
          }
        },
        {
          "step_6": {
            "code_line": "r, g, b = map(int, input_color.split())",
            "description": "We convert the input values into integers representing the RGB components."
          }
        },
        {
          "step_7": {
            "code_line": "opposite_r, opposite_g, opposite_b = opposite_color(r, g, b)",
            "description": "We call the function and pass the input RGB values to calculate the opposite color."
          }
        },
        {
          "step_8": {
            "code_line": "print(opposite_r, opposite_g, opposite_b)",
            "description": "We print the result of the opposite RGB values."
          }
        }
      ]
    }
  },
  "task_13": {
    "title": "Apply random filter",
    "type": "practical",
    "description": "Create a list of five ImageFilter filters and apply a random filter selection from the list to the sea.png graphic file.",
    "explanation": {
        "beginner": {
            "title": "What Are We Doing?",
            "content": [
                {
                    "tag": "concept",
                    "text": "We will apply different filters to an image to see how they alter its visual appearance."
                },
                {
                    "tag": "action",
                    "text": "The program will randomly choose one filter from a list and apply it to the image."
                },
                {
                    "tag": "tool",
                    "text": "We'll use the PIL library to manipulate the image and apply filters."
                }
            ]
        },
        "intermediate": {
            "title": "What's Happening Here?",
            "content": [
                {
                    "tag": "goal",
                    "text": "Our goal is to explore image processing techniques using various filters."
                },
                {
                    "tag": "filter_functionality",
                    "text": "Each filter has a specific function that enhances or alters the image in different ways."
                },
                {
                    "tag": "random_selection",
                    "text": "Using random selection allows us to see how different filters can change the same image."
                }
            ]
        },
        "advanced": {
            "title": "Deep Dive",
            "content": [
                {
                    "tag": "image_filters",
                    "text": "Image filters are algorithms that change how an image is processed to achieve desired effects."
                },
                {
                    "tag": "mathematical_operations",
                    "text": "Many filters involve complex mathematical operations on pixel values to achieve effects like sharpening or blurring."
                },
                {
                    "tag": "further_exploration",
                    "text": "Exploring other libraries or techniques can enhance our understanding of image processing."
                }
            ]
        }
    },
    "solution": {
        "code": "from PIL import Image\nimport random\n\n# Open the image\nimg = Image.open('sea.png')\npixels = img.load()\n\nwidth, height = img.size\n\ndef get_pixel(x, y):\n    if x < 0 or x >= width or y < 0 or y >= height:\n        return (0, 0, 0)\n    return pixels[x, y]\n\n# Define filter functions here (sharpen_filter, blur_filter, etc.)\n\nfilters = [sharpen_filter, blur_filter, edge_detection_filter, invert_filter, contour_filter]\nrandom.choice(filters)()",
        "steps": [
            {
                "step_1": {
                    "code_line": "from PIL import Image",
                    "description": "We import the PIL library, which is essential for image processing tasks."
                }
            },
            {
                "step_2": {
                    "code_line": "import random",
                    "description": "We import the random module to allow random selection of filters."
                }
            },
            {
                "step_3": {
                    "code_line": "img = Image.open('sea.png')",
                    "description": "We open the image file 'sea.png' to apply our filters."
                }
            },
            {
                "step_4": {
                    "code_line": "pixels = img.load()",
                    "description": "We load the pixel data of the image, enabling us to read and modify individual pixels."
                }
            },
            {
                "step_5": {
                    "code_line": "width, height = img.size",
                    "description": "We retrieve the dimensions of the image, which are necessary for pixel manipulation."
                }
            },
            {
                "step_6": {
                    "code_line": "def get_pixel(x, y):",
                    "description": "We define a helper function to safely access pixel values at given coordinates."
                }
            },
            {
                "step_7": {
                    "code_line": "if x < 0 or x >= width or y < 0 or y >= height: return (0, 0, 0)",
                    "description": "This ensures that if coordinates are out of bounds, we return a default color (black)."
                }
            },
            {
                "step_8": {
                    "code_line": "filters = [sharpen_filter, blur_filter, edge_detection_filter, invert_filter, contour_filter]",
                    "description": "We create a list of filter functions, which will be randomly selected and applied."
                }
            },
            {
                "step_9": {
                    "code_line": "random.choice(filters)()",
                    "description": "We randomly select one filter from our list and call it, applying it to the image."
                }
            },
            {
                "step_10": {
                    "code_line": "new_img.save('filtered_sea.png')",
                    "description": "The resulting image is saved with a new filename to preserve the original."
                }
            },
            {
                "step_11": {
                    "code_line": "new_img.show()",
                    "description": "Finally, we display the newly filtered image to the user."
                }
            }
        ]
    }
},
"task_14": {
    "title": "Gradient",
    "type": "practical",
    "description": "Write a gradient(color) function that creates a graphic file with a smooth color transition. The file must contain a rectangle 512 pixels long (2 pixels for each shade) and 200 pixels high. The designation of the color whose gradient is to be built is passed to the function. Color options: R, G, and B. Designation can be entered in any case.",
    "explanation": {
      "beginner": {
        "title": "What Are We Doing?",
        "content": [
          {
            "tag": "concept",
            "text": "We are going to create a smooth gradient of a single color across an image."
          },
          {
            "tag": "action",
            "text": "The program will generate an image where each vertical column represents a shade of the chosen color."
          },
          {
            "tag": "tool",
            "text": "We'll use the PIL library to create and manipulate the image."
          }
        ]
      },
      "intermediate": {
        "title": "What's Happening Here?",
        "content": [
          {
            "tag": "goal",
            "text": "Our goal is to explore how RGB values can be calculated to create a color gradient."
          },
          {
            "tag": "color_gradient",
            "text": "By adjusting the intensity of one color component, we create a transition from black to the chosen color."
          },
          {
            "tag": "user_input",
            "text": "The program takes a color designation (R, G, or B) as input and generates the corresponding gradient."
          }
        ]
      },
      "advanced": {
        "title": "Deep Dive",
        "content": [
          {
            "tag": "rgb_model",
            "text": "Understanding the RGB color model is essential for manipulating colors and creating gradients."
          },
          {
            "tag": "gradient_logic",
            "text": "The gradient is achieved by incrementally increasing the intensity of the selected color as we move across the image width."
          },
          {
            "tag": "file_output",
            "text": "Finally, the generated image is saved as 'gradient_image.png' for viewing."
          }
        ]
      }
    },
    "solution": {
      "code": "from PIL import Image\n\ndef gradient(color):\n    width = 512\n    height = 200\n    img = Image.new('RGB', (width, height))\n    for x in range(width):\n        intensity = int(255 * (x / (width - 1)))\n        if color.upper() == 'R':\n            gradient_color = (intensity, 0, 0)\n        elif color.upper() == 'G':\n            gradient_color = (0, intensity, 0)\n        elif color.upper() == 'B':\n            gradient_color = (0, 0, intensity)\n        else:\n            raise ValueError(\"Color must be 'R', 'G', or 'B'\")\n        for y in range(height):\n            img.putpixel((x, y), gradient_color)\n    img.save('gradient_image.png')\n\n# Example usage:\ngradient('R')  # Generate a red gradient",
      "steps": [
        {
          "step_1": {
            "code_line": "from PIL import Image",
            "description": "We import the PIL library to handle image creation and manipulation."
          }
        },
        {
          "step_2": {
            "code_line": "def gradient(color):",
            "description": "We define the gradient function that accepts a color parameter."
          }
        },
        {
          "step_3": {
            "code_line": "width = 512\nheight = 200",
            "description": "We set the dimensions of the image to be 512 pixels wide and 200 pixels tall."
          }
        },
        {
          "step_4": {
            "code_line": "img = Image.new('RGB', (width, height))",
            "description": "We create a new RGB image to hold our gradient."
          }
        },
        {
          "step_5": {
            "code_line": "for x in range(width):",
            "description": "We iterate over the width of the image to create the gradient column by column."
          }
        },
        {
          "step_6": {
            "code_line": "intensity = int(255 * (x / (width - 1)))",
            "description": "We calculate the intensity of the color based on the current x position."
          }
        },
        {
          "step_7": {
            "code_line": "if color.upper() == 'R':",
            "description": "We check the color input and set the corresponding RGB values for the gradient."
          }
        },
        {
          "step_8": {
            "code_line": "for y in range(height):",
            "description": "We loop through the height of the image to fill each pixel in the current column."
          }
        },
        {
          "step_9": {
            "code_line": "img.putpixel((x, y), gradient_color)",
            "description": "We apply the calculated gradient color to each pixel in the current column."
          }
        },
        {
          "step_10": {
            "code_line": "img.save('gradient_image.png')",
            "description": "We save the final image as 'gradient_image.png'."
          }
        }
      ]
    }
  },
  "task_15": {
    "title": "Average Photo Color",
    "type": "practical",
    "description": "Implement an algorithm that calculates the average value of each component R, G, B from the image 'sea.PNG' and displays these values on the screen separated by a space.",
    "explanation": {
      "beginner": {
        "title": "Understanding Average Color",
        "content": [
          {
            "tag": "concept",
            "text": "We will calculate the average color of an image by finding the mean of the red, green, and blue pixel values."
          },
          {
            "tag": "action",
            "text": "The program will load the image and iterate through its pixels to compute the average intensity for each color component."
          },
          {
            "tag": "result",
            "text": "The final output will be three numbers representing the average red, green, and blue values."
          }
        ]
      },
      "intermediate": {
        "title": "How the Calculation Works",
        "content": [
          {
            "tag": "goal",
            "text": "The goal is to determine the average RGB values of an image, which helps to understand its overall color tone."
          },
          {
            "tag": "method",
            "text": "By summing the values of all pixels and dividing by the total number of pixels, we can find the average for each color component."
          },
          {
            "tag": "use_case",
            "text": "This technique is useful in scenarios where an image cannot be displayed, allowing us to show a block of the average color instead."
          }
        ]
      },
      "advanced": {
        "title": "Technical Implementation",
        "content": [
          {
            "tag": "rgb_model",
            "text": "Understanding the RGB color model is essential since it defines how colors are represented in images."
          },
          {
            "tag": "performance",
            "text": "Using efficient pixel access and aggregation techniques ensures that the algorithm runs quickly, even for large images."
          },
          {
            "tag": "library_use",
            "text": "We'll leverage the PIL library to handle image loading and pixel manipulation effectively."
          }
        ]
      }
    },
    "solution": {
      "code": "from PIL import Image\n\n\ndef average_photo_color(image_path):\n    # Load the image\n    img = Image.open(image_path)\n    pixels = img.load()  # Load pixel data\n    width, height = img.size  # Get dimensions of the image\n\n    # Initialize sums for RGB components\n    r_total = g_total = b_total = 0\n\n    # Loop through each pixel in the image\n    for x in range(width):\n        for y in range(height):\n            r, g, b = pixels[x, y]  # Get the RGB value of the pixel\n            r_total += r  # Accumulate red values\n            g_total += g  # Accumulate green values\n            b_total += b  # Accumulate blue values\n\n    # Calculate average values for each component\n    total_pixels = width * height  # Total number of pixels\n    avg_r = r_total // total_pixels  # Average red value\n    avg_g = g_total // total_pixels  # Average green value\n    avg_b = b_total // total_pixels  # Average blue value\n\n    # Print the average RGB values\n    print(avg_r, avg_g, avg_b)\n\n# Example usage:\naverage_photo_color('sea.PNG')",
      "steps": [
        {
          "step_1": {
            "code_line": "from PIL import Image",
            "description": "We import the PIL library to handle image loading and manipulation."
          }
        },
        {
          "step_2": {
            "code_line": "def average_photo_color(image_path):",
            "description": "We define a function that takes the path to the image as an argument."
          }
        },
        {
          "step_3": {
            "code_line": "img = Image.open(image_path)",
            "description": "We load the image using the provided path."
          }
        },
        {
          "step_4": {
            "code_line": "pixels = img.load()",
            "description": "We load the pixel data of the image into a variable for easy access."
          }
        },
        {
          "step_5": {
            "code_line": "width, height = img.size",
            "description": "We retrieve the dimensions of the image for iterating over its pixels."
          }
        },
        {
          "step_6": {
            "code_line": "r_total = g_total = b_total = 0",
            "description": "We initialize variables to hold the cumulative sums of each color component."
          }
        },
        {
          "step_7": {
            "code_line": "for x in range(width):",
            "description": "We start a loop to iterate over each pixel column in the image."
          }
        },
        {
          "step_8": {
            "code_line": "for y in range(height):",
            "description": "We start a nested loop to iterate over each pixel row in the current column."
          }
        },
        {
          "step_9": {
            "code_line": "r, g, b = pixels[x, y]",
            "description": "We retrieve the RGB values of the current pixel."
          }
        },
        {
          "step_10": {
            "code_line": "r_total += r",
            "description": "We add the red component of the current pixel to the total red sum."
          }
        },
        {
          "step_11": {
            "code_line": "g_total += g",
            "description": "We add the green component of the current pixel to the total green sum."
          }
        },
        {
          "step_12": {
            "code_line": "b_total += b",
            "description": "We add the blue component of the current pixel to the total blue sum."
          }
        },
        {
          "step_13": {
            "code_line": "total_pixels = width * height",
            "description": "We calculate the total number of pixels in the image."
          }
        },
        {
          "step_14": {
            "code_line": "avg_r = r_total // total_pixels",
            "description": "We calculate the average red value by dividing the total red sum by the number of pixels."
          }
        },
        {
          "step_15": {
            "code_line": "avg_g = g_total // total_pixels",
            "description": "We calculate the average green value by dividing the total green sum by the number of pixels."
          }
        },
        {
          "step_16": {
            "code_line": "avg_b = b_total // total_pixels",
            "description": "We calculate the average blue value by dividing the total blue sum by the number of pixels."
          }
        },
        {
          "step_17": {
            "code_line": "print(avg_r, avg_g, avg_b)",
            "description": "We print the average RGB values separated by spaces."
          }
        },
        {
          "step_18": {
            "code_line": "average_photo_color('sea.PNG')",
            "description": "We call the function with the image file name to execute the average color calculation."
          }
        }
      ]
    }
  }
  }
    },
    "3": {
        "title": "Wave Library",
        "tasks": {
            "task_1": {
                "title": "Sound Processing with Python Wave Library",
                "type":"theoretical",
                "sections": [
                  {
                    "heading": "Understanding WAV Files",
                    "content": [
                      {
                        "definition": "WAV files are a standard audio file format used for storing waveform data. They are widely used in audio applications due to their uncompressed nature, providing high-quality sound."
                      },
                      {
                        "structure": "A WAV file consists of a header (containing metadata about the file) followed by the audio data. The header specifies properties like sample rate, bit depth, and the number of channels."
                      }
                    ]
                  },
                  {
                    "heading": "Python Wave Library Basics",
                    "content": [
                      {
                        "library_overview": "The wave module in Python provides a straightforward interface for reading and writing WAV files. It is part of the standard library, so no additional installation is required."
                      },
                      {
                        "key_functions": [
                          {
                            "function": "wave.open(filename, mode)",
                            "description": "Opens a WAV file for reading or writing."
                          },
                          {
                            "function": "getnchannels()",
                            "description": "Returns the number of audio channels (1 for mono, 2 for stereo)."
                          },
                          {
                            "function": "getframerate()",
                            "description": "Returns the sample rate (number of samples per second)."
                          },
                          {
                            "function": "getnframes()",
                            "description": "Returns the total number of audio frames."
                          },
                          {
                            "function": "readframes(n)",
                            "description": "Reads n frames from the audio file."
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "heading": "Importance of Sound Processing",
                    "content": [
                      {
                        "applications": "Sound processing skills are essential in various fields such as music production, game development, and multimedia applications. Understanding how to manipulate audio can lead to creating unique audio experiences."
                      },
                      {
                        "real_world_examples": [
                          {
                            "example": "Music Analysis",
                            "description": "Developers can analyze music to extract features like tempo, rhythm, and key."
                          },
                          {
                            "example": "Game Development",
                            "description": "Sound effects and background music can be dynamically adjusted based on user interactions or game events."
                          },
                          {
                            "example": "Speech Recognition",
                            "description": "Knowledge of audio processing is fundamental for developing applications that convert spoken language into text."
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "heading": "Hands-On Learning",
                    "content": [
                      {
                        "basic_task": "Start by writing a program that reads a WAV file and prints out its properties, such as the number of channels and frame rate."
                      },
                      {
                        "intermediate_challenge": "Modify an existing WAV file by changing its volume or applying effects like echo or reverb."
                      },
                      {
                        "advanced_project": "Develop a simple audio analysis tool that visualizes audio waveforms or calculates frequency spectra."
                      }
                    ]
                  }
                ]
              },
              "task_2": {
    "title": "Copying WAV Files",
    "type": "practical",
    "description": "Download a WAV file and create a copy of it.",
    "explanation": {
      "beginner": {
        "title": "What Are We Doing?",
        "content": [
          {
            "tag": "concept",
            "text": "We will copy an audio file from one location to another."
          },
          {
            "tag": "action",
            "text": "The program will read the original WAV file and write its contents to a new file."
          },
          {
            "tag": "tool",
            "text": "We'll use the 'wave' and 'struct' libraries to handle the WAV file format."
          }
        ]
      },
      "intermediate": {
        "title": "What's Happening Here?",
        "content": [
          {
            "tag": "file_handling",
            "text": "The program opens the original WAV file in read mode and creates a new WAV file in write mode."
          },
          {
            "tag": "data_reading",
            "text": "We read the audio data from the original file and write it to the new file."
          },
          {
            "tag": "parameters_copying",
            "text": "We ensure that all relevant audio parameters (like sample width and frame rate) are copied to the new file."
          }
        ]
      },
      "advanced": {
        "title": "Deep Dive",
        "content": [
          {
            "tag": "library_usage",
            "text": "The 'wave' module provides methods to read and write WAV files, while 'struct' is used for converting between Python values and C structs represented as Python bytes."
          },
          {
            "tag": "audio_format",
            "text": "Understanding the WAV file structure is crucial, as it contains headers and data sections that define the audio characteristics."
          },
          {
            "tag": "error_handling",
            "text": "We should implement error handling to manage issues like file not found or read/write permissions."
          }
        ]
      }
    },
    "solution": {
      "code": "import wave\n\n# Open the original WAV file in read mode\nwith wave.open('in.wav', 'rb') as original:\n    # Create a new WAV file in write mode\n    with wave.open('out.wav', 'wb') as copy:\n        # Set parameters for the new file\n        copy.setparams(original.getparams())\n        # Read frames from the original file\n        frames = original.readframes(original.getnframes())\n        # Write frames to the new file\n        copy.writeframes(frames)",
      "steps": [
        {
          "step_1": {
            "code_line": "import wave",
            "description": "We import the wave module to handle WAV file operations."
          }
        },
        {
          "step_2": {
            "code_line": "with wave.open('in.wav', 'rb') as original:",
            "description": "We open the original WAV file named 'in.wav' in read mode ('rb')."
          }
        },
        {
          "step_3": {
            "code_line": "with wave.open('out.wav', 'wb') as copy:",
            "description": "We create a new WAV file named 'out.wav' in write mode ('wb')."
          }
        },
        {
          "step_4": {
            "code_line": "copy.setparams(original.getparams())",
            "description": "We copy the parameters from the original file to the new file, ensuring they match."
          }
        },
        {
          "step_5": {
            "code_line": "frames = original.readframes(original.getnframes())",
            "description": "We read all the audio frames from the original file."
          }
        },
        {
          "step_6": {
            "code_line": "copy.writeframes(frames)",
            "description": "We write the read frames to the new WAV file, effectively creating a copy."
          }
        }
      ]
    }
  },
  "task_3": {
  "title": "Count Frames",
  "type": "practical",
  "description": "Count the number of frames in a WAV audio file using the Wave and Struct libraries.",
  "explanation": {
    "beginner": {
      "title": "What Are We Doing?",
      "content": [
        {
          "tag": "concept",
          "text": "We will open a WAV audio file and count how many frames it contains."
        },
        {
          "tag": "action",
          "text": "The program will read the audio file and output the total frame count."
        },
        {
          "tag": "tool",
          "text": "We'll use the Wave and Struct libraries to handle audio file operations."
        }
      ]
    },
    "intermediate": {
      "title": "What's Happening Here?",
      "content": [
        {
          "tag": "goal",
          "text": "Our goal is to understand the structure of WAV files and extract useful information from them."
        },
        {
          "tag": "file_handling",
          "text": "We will learn how to open WAV files and read their properties using the Wave library."
        },
        {
          "tag": "data_format",
          "text": "Understanding how frames are represented in the audio data is crucial for accurate counting."
        }
      ]
    },
    "advanced": {
      "title": "Deep Dive",
      "content": [
        {
          "tag": "audio_processing",
          "text": "We'll explore the internal representation of audio frames in WAV files and how they relate to sample rate and duration."
        },
        {
          "tag": "error_handling",
          "text": "We will consider adding error handling to manage cases where the audio file might be corrupt or unreadable."
        },
        {
          "tag": "performance",
          "text": "Optimizing the reading process for larger audio files will help improve performance and reduce latency."
        }
      ]
    }
  },
  "solution": {
    "code": "import wave\nimport struct\n\n# Open the WAV file\nfile_path = 'in.wav'\nwith wave.open(file_path, 'rb') as wav_file:\n    # Get the number of frames\n    num_frames = wav_file.getnframes()\n\nprint('Number of frames:', num_frames)",
    "steps": [
      {
        "step_1": {
          "code_line": "import wave",
          "description": "We import the wave module, which allows us to read and manipulate WAV files."
        }
      },
      {
        "step_2": {
          "code_line": "import struct",
          "description": "We import the struct module to help with packing and unpacking binary data."
        }
      },
      {
        "step_3": {
          "code_line": "file_path = 'in.wav'",
          "description": "We specify the path of the WAV file we want to open."
        }
      },
      {
        "step_4": {
          "code_line": "with wave.open(file_path, 'rb') as wav_file:",
          "description": "We open the WAV file in read-binary mode, which allows us to access its frame data."
        }
      },
      {
        "step_5": {
          "code_line": "num_frames = wav_file.getnframes()",
          "description": "We use the getnframes method to retrieve the total number of frames in the audio file."
        }
      },
      {
        "step_6": {
          "code_line": "print('Number of frames:', num_frames)",
          "description": "We print the total number of frames to the console."
        }
      }
    ]
  }
},
"task_4": {
  "title": "Half Sound",
  "type": "practical",
  "description": "Extract the first half of a WAV audio file and save it as a new file.",
  "explanation": {
    "beginner": {
      "title": "What Are We Doing?",
      "content": [
        {
          "tag": "concept",
          "text": "We will read a WAV audio file and create a new file containing only the first half of the audio."
        },
        {
          "tag": "action",
          "text": "The program will open the audio file, calculate the midpoint, and save the first half."
        },
        {
          "tag": "tool",
          "text": "We'll use the Wave and Struct libraries to handle audio file operations."
        }
      ]
    },
    "intermediate": {
      "title": "What's Happening Here?",
      "content": [
        {
          "tag": "goal",
          "text": "Our goal is to manipulate audio files by slicing them based on their frame count."
        },
        {
          "tag": "file_handling",
          "text": "We will learn how to open a WAV file, read its frames, and write a new WAV file."
        },
        {
          "tag": "data_format",
          "text": "Understanding the structure of WAV files is important for accurately extracting audio data."
        }
      ]
    },
    "advanced": {
      "title": "Deep Dive",
      "content": [
        {
          "tag": "audio_processing",
          "text": "We'll explore the internal representation of audio frames in WAV files and how to manage them."
        },
        {
          "tag": "error_handling",
          "text": "We should add error handling to manage potential issues with file reading and writing."
        },
        {
          "tag": "performance",
          "text": "Optimizing the extraction process for larger files can improve efficiency and resource usage."
        }
      ]
    }
  },
  "solution": {
    "code": "import wave\n\n# Open the original WAV file\nfile_path = 'in.wav'\nout_path = 'out.wav'\n\nwith wave.open(file_path, 'rb') as wav_file:\n    # Get parameters and number of frames\n    params = wav_file.getparams()\n    num_frames = wav_file.getnframes()\n    half_frames = num_frames // 2\n\n    # Read the first half of the frames\n    frames = wav_file.readframes(half_frames)\n\n# Write the first half to a new WAV file\nwith wave.open(out_path, 'wb') as out_file:\n    out_file.setparams(params)\n    out_file.writeframes(frames)\n\nprint('First half of the audio has been saved as out.wav')",
    "steps": [
      {
        "step_1": {
          "code_line": "import wave",
          "description": "We import the wave module to read and write WAV audio files."
        }
      },
      {
        "step_2": {
          "code_line": "file_path = 'in.wav'",
          "description": "We specify the path of the input WAV file we want to read."
        }
      },
      {
        "step_3": {
          "code_line": "out_path = 'out.wav'",
          "description": "We specify the path where the output WAV file will be saved."
        }
      },
      {
        "step_4": {
          "code_line": "with wave.open(file_path, 'rb') as wav_file:",
          "description": "We open the original WAV file in read-binary mode."
        }
      },
      {
        "step_5": {
          "code_line": "params = wav_file.getparams()",
          "description": "We retrieve the parameters of the WAV file (like channels, sample width, and frame rate)."
        }
      },
      {
        "step_6": {
          "code_line": "num_frames = wav_file.getnframes()",
          "description": "We get the total number of frames in the audio file."
        }
      },
      {
        "step_7": {
          "code_line": "half_frames = num_frames // 2",
          "description": "We calculate the number of frames that represent the first half of the audio."
        }
      },
      {
        "step_8": {
          "code_line": "frames = wav_file.readframes(half_frames)",
          "description": "We read the first half of the audio frames."
        }
      },
      {
        "step_9": {
          "code_line": "with wave.open(out_path, 'wb') as out_file:",
          "description": "We open a new WAV file in write-binary mode to save the extracted audio."
        }
      },
      {
        "step_10": {
          "code_line": "out_file.setparams(params)",
          "description": "We set the parameters of the new file to match the original WAV file."
        }
      },
      {
        "step_11": {
          "code_line": "out_file.writeframes(frames)",
          "description": "We write the extracted frames to the new WAV file."
        }
      },
      {
        "step_12": {
          "code_line": "print('First half of the audio has been saved as out.wav')",
          "description": "We print a confirmation message indicating that the process is complete."
        }
      }
    ]
  }
},
"task_5": {
  "title": "Reverse Sound",
  "type": "practical",
  "description": "Reverse the audio of a WAV file and save it as a new file.",
  "explanation": {
    "beginner": {
      "title": "What Are We Doing?",
      "content": [
        {
          "tag": "concept",
          "text": "We will read a WAV audio file and create a new file that contains the audio played in reverse."
        },
        {
          "tag": "action",
          "text": "The program will open the audio file, read all frames, reverse them, and save the new audio."
        },
        {
          "tag": "tool",
          "text": "We'll use the Wave and Struct libraries to handle audio file operations."
        }
      ]
    },
    "intermediate": {
      "title": "What's Happening Here?",
      "content": [
        {
          "tag": "goal",
          "text": "Our goal is to manipulate audio files by reversing the order of the frames."
        },
        {
          "tag": "file_handling",
          "text": "We will learn how to read all frames from a WAV file and write them in reverse order to a new file."
        },
        {
          "tag": "data_format",
          "text": "Understanding the structure of WAV files is crucial for manipulating audio data effectively."
        }
      ]
    },
    "advanced": {
      "title": "Deep Dive",
      "content": [
        {
          "tag": "audio_processing",
          "text": "We'll explore how audio frames are stored in WAV files and how to reverse them programmatically."
        },
        {
          "tag": "error_handling",
          "text": "We should implement error handling to manage potential issues with file operations."
        },
        {
          "tag": "performance",
          "text": "Considering performance optimizations for larger audio files will help improve our program's efficiency."
        }
      ]
    }
  },
  "solution": {
    "code": "import wave\n\n# Open the original WAV file\nfile_path = 'in.wav'\nout_path = 'out.wav'\n\nwith wave.open(file_path, 'rb') as wav_file:\n    # Get parameters and read all frames\n    params = wav_file.getparams()\n    frames = wav_file.readframes(wav_file.getnframes())\n\n    # Reverse the frames\n    reversed_frames = frames[::-1]\n\n# Write the reversed frames to a new WAV file\nwith wave.open(out_path, 'wb') as out_file:\n    out_file.setparams(params)\n    out_file.writeframes(reversed_frames)\n\nprint('Reversed audio has been saved as out.wav')",
    "steps": [
      {
        "step_1": {
          "code_line": "import wave",
          "description": "We import the wave module to read and write WAV audio files."
        }
      },
      {
        "step_2": {
          "code_line": "file_path = 'in.wav'",
          "description": "We specify the path of the input WAV file we want to read."
        }
      },
      {
        "step_3": {
          "code_line": "out_path = 'out.wav'",
          "description": "We specify the path where the output WAV file will be saved."
        }
      },
      {
        "step_4": {
          "code_line": "with wave.open(file_path, 'rb') as wav_file:",
          "description": "We open the original WAV file in read-binary mode."
        }
      },
      {
        "step_5": {
          "code_line": "params = wav_file.getparams()",
          "description": "We retrieve the parameters of the WAV file (like channels, sample width, and frame rate)."
        }
      },
      {
        "step_6": {
          "code_line": "frames = wav_file.readframes(wav_file.getnframes())",
          "description": "We read all frames from the audio file."
        }
      },
      {
        "step_7": {
          "code_line": "reversed_frames = frames[::-1]",
          "description": "We reverse the order of the audio frames."
        }
      },
      {
        "step_8": {
          "code_line": "with wave.open(out_path, 'wb') as out_file:",
          "description": "We open a new WAV file in write-binary mode to save the reversed audio."
        }
      },
      {
        "step_9": {
          "code_line": "out_file.setparams(params)",
          "description": "We set the parameters of the new file to match the original WAV file."
        }
      },
      {
        "step_10": {
          "code_line": "out_file.writeframes(reversed_frames)",
          "description": "We write the reversed frames to the new WAV file."
        }
      },
      {
        "step_11": {
          "code_line": "print('Reversed audio has been saved as out.wav')",
          "description": "We print a confirmation message indicating that the process is complete."
        }
      }
    ]
  }
},
"task_6": {
  "title": "Speed Up Twice",
  "type": "practical",
  "description": "Speed up a WAV audio file by a factor of two and save it as a new file.",
  "explanation": {
    "beginner": {
      "title": "What Are We Doing?",
      "content": [
        {
          "tag": "concept",
          "text": "We will read a WAV audio file and create a new file that plays the audio twice as fast."
        },
        {
          "tag": "action",
          "text": "The program will open the audio file, adjust the frame rate, and save the new audio."
        },
        {
          "tag": "tool",
          "text": "We'll use the Wave and Struct libraries to handle audio file operations."
        }
      ]
    },
    "intermediate": {
      "title": "What's Happening Here?",
      "content": [
        {
          "tag": "goal",
          "text": "Our goal is to manipulate audio files by altering their playback speed."
        },
        {
          "tag": "file_handling",
          "text": "We will learn how to read audio frames, adjust the frame count, and write a new WAV file."
        },
        {
          "tag": "data_format",
          "text": "Understanding how frame rates affect audio playback is crucial for this task."
        }
      ]
    },
    "advanced": {
      "title": "Deep Dive",
      "content": [
        {
          "tag": "audio_processing",
          "text": "We'll explore the internal representation of audio data and how frame rates determine playback speed."
        },
        {
          "tag": "error_handling",
          "text": "We should implement error handling to manage potential issues with file operations."
        },
        {
          "tag": "performance",
          "text": "Optimizing the process for larger audio files can improve efficiency."
        }
      ]
    }
  },
  "solution": {
    "code": "import wave\n\n# Open the original WAV file\nfile_path = 'in.wav'\nout_path = 'out.wav'\n\nwith wave.open(file_path, 'rb') as wav_file:\n    # Get parameters\n    params = wav_file.getparams()\n    frame_rate = params.framerate\n    num_frames = wav_file.getnframes()\n\n    # Read all frames\n    frames = wav_file.readframes(num_frames)\n\n    # Create a new WAV file with double speed\n    new_params = params._replace(framerate=frame_rate * 2)\n\n# Write the new WAV file\nwith wave.open(out_path, 'wb') as out_file:\n    out_file.setparams(new_params)\n    out_file.writeframes(frames)\n\nprint('The audio has been sped up and saved as out.wav')",
    "steps": [
      {
        "step_1": {
          "code_line": "import wave",
          "description": "We import the wave module to read and write WAV audio files."
        }
      },
      {
        "step_2": {
          "code_line": "file_path = 'in.wav'",
          "description": "We specify the path of the input WAV file we want to read."
        }
      },
      {
        "step_3": {
          "code_line": "out_path = 'out.wav'",
          "description": "We specify the path where the output WAV file will be saved."
        }
      },
      {
        "step_4": {
          "code_line": "with wave.open(file_path, 'rb') as wav_file:",
          "description": "We open the original WAV file in read-binary mode."
        }
      },
      {
        "step_5": {
          "code_line": "params = wav_file.getparams()",
          "description": "We retrieve the parameters of the WAV file (like channels, sample width, and frame rate)."
        }
      },
      {
        "step_6": {
          "code_line": "frame_rate = params.framerate",
          "description": "We store the original frame rate for adjustment."
        }
      },
      {
        "step_7": {
          "code_line": "num_frames = wav_file.getnframes()",
          "description": "We get the total number of frames in the audio file."
        }
      },
      {
        "step_8": {
          "code_line": "frames = wav_file.readframes(num_frames)",
          "description": "We read all frames from the audio file."
        }
      },
      {
        "step_9": {
          "code_line": "new_params = params._replace(framerate=frame_rate * 2)",
          "description": "We create new parameters for the output file with double the original frame rate."
        }
      },
      {
        "step_10": {
          "code_line": "with wave.open(out_path, 'wb') as out_file:",
          "description": "We open a new WAV file in write-binary mode to save the sped-up audio."
        }
      },
      {
        "step_11": {
          "code_line": "out_file.setparams(new_params)",
          "description": "We set the parameters of the new file to the modified parameters."
        }
      },
      {
        "step_12": {
          "code_line": "out_file.writeframes(frames)",
          "description": "We write the original frames to the new WAV file."
        }
      },
      {
        "step_13": {
          "code_line": "print('The audio has been sped up and saved as out.wav')",
          "description": "We print a confirmation message indicating that the process is complete."
        }
      }
    ]
  }
},
"task_7": {
  "title": "Slow Down Twice",
  "type": "practical",
  "description": "Slow down a WAV audio file by a factor of two and save it as a new file.",
  "explanation": {
    "beginner": {
      "title": "What Are We Doing?",
      "content": [
        {
          "tag": "concept",
          "text": "We will read a WAV audio file and create a new file that plays the audio at half speed."
        },
        {
          "tag": "action",
          "text": "The program will open the audio file, adjust the frame rate, and save the new audio."
        },
        {
          "tag": "tool",
          "text": "We'll use the Wave and Struct libraries to handle audio file operations."
        }
      ]
    },
    "intermediate": {
      "title": "What's Happening Here?",
      "content": [
        {
          "tag": "goal",
          "text": "Our goal is to manipulate audio files by altering their playback speed."
        },
        {
          "tag": "file_handling",
          "text": "We will learn how to read audio frames, adjust the frame count, and write a new WAV file."
        },
        {
          "tag": "data_format",
          "text": "Understanding how frame rates affect audio playback is crucial for this task."
        }
      ]
    },
    "advanced": {
      "title": "Deep Dive",
      "content": [
        {
          "tag": "audio_processing",
          "text": "We'll explore the internal representation of audio data and how frame rates determine playback speed."
        },
        {
          "tag": "error_handling",
          "text": "We should implement error handling to manage potential issues with file operations."
        },
        {
          "tag": "performance",
          "text": "Optimizing the process for larger audio files can improve efficiency."
        }
      ]
    }
  },
  "solution": {
    "code": "import wave\n\n# Open the original WAV file\nfile_path = 'in.wav'\nout_path = 'out.wav'\n\nwith wave.open(file_path, 'rb') as wav_file:\n    # Get parameters\n    params = wav_file.getparams()\n    frame_rate = params.framerate\n    num_frames = wav_file.getnframes()\n\n    # Read all frames\n    frames = wav_file.readframes(num_frames)\n\n    # Create a new WAV file with half speed\n    new_params = params._replace(framerate=frame_rate // 2)\n\n# Write the new WAV file\nwith wave.open(out_path, 'wb') as out_file:\n    out_file.setparams(new_params)\n    out_file.writeframes(frames)\n\nprint('The audio has been slowed down and saved as out.wav')",
    "steps": [
      {
        "step_1": {
          "code_line": "import wave",
          "description": "We import the wave module to read and write WAV audio files."
        }
      },
      {
        "step_2": {
          "code_line": "file_path = 'in.wav'",
          "description": "We specify the path of the input WAV file we want to read."
        }
      },
      {
        "step_3": {
          "code_line": "out_path = 'out.wav'",
          "description": "We specify the path where the output WAV file will be saved."
        }
      },
      {
        "step_4": {
          "code_line": "with wave.open(file_path, 'rb') as wav_file:",
          "description": "We open the original WAV file in read-binary mode."
        }
      },
      {
        "step_5": {
          "code_line": "params = wav_file.getparams()",
          "description": "We retrieve the parameters of the WAV file (like channels, sample width, and frame rate)."
        }
      },
      {
        "step_6": {
          "code_line": "frame_rate = params.framerate",
          "description": "We store the original frame rate for adjustment."
        }
      },
      {
        "step_7": {
          "code_line": "num_frames = wav_file.getnframes()",
          "description": "We get the total number of frames in the audio file."
        }
      },
      {
        "step_8": {
          "code_line": "frames = wav_file.readframes(num_frames)",
          "description": "We read all frames from the audio file."
        }
      },
      {
        "step_9": {
          "code_line": "new_params = params._replace(framerate=frame_rate // 2)",
          "description": "We create new parameters for the output file with half the original frame rate."
        }
      },
      {
        "step_10": {
          "code_line": "with wave.open(out_path, 'wb') as out_file:",
          "description": "We open a new WAV file in write-binary mode to save the slowed-down audio."
        }
      },
      {
        "step_11": {
          "code_line": "out_file.setparams(new_params)",
          "description": "We set the parameters of the new file to the modified parameters."
        }
      },
      {
        "step_12": {
          "code_line": "out_file.writeframes(frames)",
          "description": "We write the original frames to the new WAV file."
        }
      },
      {
        "step_13": {
          "code_line": "print('The audio has been slowed down and saved as out.wav')",
          "description": "We print a confirmation message indicating that the process is complete."
        }
      }
    ]
  }
}
            }
        },
    "4": {
        "title": "PyGame. Draw Module",
        "tasks": {
            "task_1": {
    "title": "Introduction to Pygame",
    "type": "theoretical",
    "description": "Learn about the Pygame library and its capabilities for game development and graphics.",
    "content": {
      "overview": {
        "definition": "Pygame is a Python library designed for writing video games and multimedia applications. It allows developers to create fully interactive programs with ease.",
        "features": [
          "Graphics rendering for shapes and images, enabling dynamic visuals.",
          "Sound handling for music and sound effects, adding depth to applications.",
          "Event management for keyboard and mouse input, making programs interactive.",
          "Support for image manipulation and simple animations.",
          "Cross-platform compatibility, allowing games to run on various operating systems."
        ],
        "benefits": [
          "User-friendly for beginners, with a straightforward API.",
          "Strong community support and numerous resources for learning.",
          "Flexible enough for small projects as well as larger games."
        ]
      },
      "drawing_shapes": {
        "concept": "In Pygame, graphics are drawn on surfaces, such as the main game window, allowing for various visual elements to be created.",
        "example_code": "import pygame\n\npygame.init()\nscreen = pygame.display.set_mode((800, 600))\nscreen.fill((255, 255, 255))  # White background\npygame.draw.rect(screen, (0, 128, 255), (100, 100, 200, 100))  # Draw a blue rectangle\npygame.display.flip()",
        "explanation": "This code initializes Pygame, sets up a display window, fills it with a white background, and draws a blue rectangle. The `pygame.display.flip()` function updates the display to show the new graphics."
      },
      "event_handling": {
        "concept": "Managing user input is crucial for creating interactive applications. Pygame uses an event loop to handle events like keyboard presses and mouse movements.",
        "example_code": "running = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False",
        "explanation": "This code snippet creates a loop that continues running until the user closes the window. It checks for events and processes them, ensuring that the application can respond to user actions."
      },
      "best_practices": {
        "tips": [
          "Start with small projects, like drawing shapes or simple animations, to understand basic concepts.",
          "Experiment with changing colors, shapes, and positions in examples to see how they affect the output.",
          "Utilize online resources, forums, and Pygame documentation to deepen your understanding.",
          "Organize your code well and use functions to keep your projects manageable as they grow."
        ],
        "next_steps": "After mastering the basics, explore more advanced topics like sprite animation, collision detection, and sound integration. Experiment with creating simple games to solidify your skills."
      },
      "resources": {
        "official_documentation": "https://www.pygame.org/docs/",
        "tutorials": [
          "Beginner tutorials on creating games with Pygame.",
          "YouTube video series on Pygame basics and project ideas.",
          "Community forums and Discord channels for Pygame developers."
        ]
      }
    }
            },
            "task_2": {
              "title": "Create Game Window",
              "type": "practical",
              "description": "Write a program to create a game window with a size of 600x400 pixels, ensuring it closes correctly.",
              "explanation": {
                "beginner": {
                  "title": "What Are We Doing?",
                  "content": [
                    {
                      "tag": "concept",
                      "text": "We will create a basic game window using Pygame, which is essential for any game or interactive application."
                    },
                    {
                      "tag": "action",
                      "text": "The program will initialize Pygame, set up the window, and handle the closing event properly."
                    },
                    {
                      "tag": "tool",
                      "text": "We'll use the Pygame library to manage the graphics and window functionalities."
                    }
                  ]
                },
                "intermediate": {
                  "title": "What's Happening Here?",
                  "content": [
                    {
                      "tag": "goal",
                      "text": "Our goal is to establish a foundation by creating a responsive game window."
                    },
                    {
                      "tag": "window_management",
                      "text": "Understanding how to create and manage a window is crucial for all future Pygame projects."
                    },
                    {
                      "tag": "event_handling",
                      "text": "We will learn how to listen for events to ensure the window closes correctly when requested."
                    }
                  ]
                },
                "advanced": {
                  "title": "Deep Dive",
                  "content": [
                    {
                      "tag": "graphics_initialization",
                      "text": "We will explore how Pygame initializes graphics and what happens behind the scenes when we create a window."
                    },
                    {
                      "tag": "main_loop",
                      "text": "The main loop of a Pygame application is where all events are processed, and graphics are updated."
                    },
                    {
                      "tag": "performance_considerations",
                      "text": "Discuss best practices for keeping the game loop efficient, ensuring smooth performance."
                    }
                  ]
                }
              },
              "solution": {
                "code": "import pygame\n\n# Initialize Pygame\npygame.init()\n\n# Set up the display\nwindow_size = (600, 400)\nscreen = pygame.display.set_mode(window_size)\npygame.display.set_caption('Game Window')\n\n# Main loop\nrunning = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n\n# Quit Pygame\npygame.quit()",
                "steps": [
                  {
                    "step_1": {
                      "code_line": "import pygame",
                      "description": "We import the Pygame library to access its functionalities."
                    }
                  },
                  {
                    "step_2": {
                      "code_line": "pygame.init()",
                      "description": "We initialize all imported Pygame modules to set up the environment for our application."
                    }
                  },
                  {
                    "step_3": {
                      "code_line": "window_size = (600, 400)",
                      "description": "We define the size of the game window as 600 pixels wide and 400 pixels high."
                    }
                  },
                  {
                    "step_4": {
                      "code_line": "screen = pygame.display.set_mode(window_size)",
                      "description": "We create the game window using the specified dimensions."
                    }
                  },
                  {
                    "step_5": {
                      "code_line": "pygame.display.set_caption('Game Window')",
                      "description": "We set the title of the window, which appears in the title bar."
                    }
                  },
                  {
                    "step_6": {
                      "code_line": "while running:",
                      "description": "We enter the main loop, which will keep the program running until we close the window."
                    }
                  },
                  {
                    "step_7": {
                      "code_line": "for event in pygame.event.get():",
                      "description": "We retrieve all events that have occurred since the last iteration of the loop."
                    }
                  },
                  {
                    "step_8": {
                      "code_line": "if event.type == pygame.QUIT:",
                      "description": "We check if the quit event (window close button) has been triggered."
                    }
                  },
                  {
                    "step_9": {
                      "code_line": "running = False",
                      "description": "If the quit event is detected, we set running to False to exit the loop."
                    }
                  },
                  {
                    "step_10": {
                      "code_line": "pygame.quit()",
                      "description": "After exiting the loop, we call pygame.quit() to properly clean up resources."
                    }
                  }
                ]
              }
            },
            "task_3": {
    "title": "Create a Triangle",
    "type": "practical",
    "description": "Write a program to create a triangle on a 500x500 pixel screen.",
    "explanation": {
      "beginner": {
        "title": "What Are We Doing?",
        "content": [
          {
            "tag": "concept",
            "text": "We will draw a triangle on the screen using Pygame."
          },
          {
            "tag": "action",
            "text": "The program will set up a display window and render a triangle using defined vertices."
          },
          {
            "tag": "tool",
            "text": "We'll use the Pygame library to handle graphics operations."
          }
        ]
      },
      "intermediate": {
        "title": "What's Happening Here?",
        "content": [
          {
            "tag": "goal",
            "text": "Our goal is to create a visual representation of a triangle in a Pygame window."
          },
          {
            "tag": "geometry",
            "text": "We will define the triangle's vertices and understand how coordinates work in a 2D space."
          },
          {
            "tag": "color_management",
            "text": "Learn about defining colors using RGB values to fill the triangle."
          }
        ]
      },
      "advanced": {
        "title": "Deep Dive",
        "content": [
          {
            "tag": "graphics_pipeline",
            "text": "Explore how Pygame renders shapes through its graphics pipeline."
          },
          {
            "tag": "event_loop",
            "text": "Understand the significance of the main loop in processing events and updating the display."
          },
          {
            "tag": "performance",
            "text": "Discuss ways to optimize rendering for more complex shapes and animations in future projects."
          }
        ]
      }
    },
    "solution": {
      "code": "import pygame\nimport sys\n\n# Initialize pygame\npygame.init()\n\n# Screen dimensions\nscreen_width = 500\nscreen_height = 500\n\n# Set up the display\nscreen = pygame.display.set_mode((screen_width, screen_height))\np pygame.display.set_caption('Triangle')\n\n# Define colors\nWHITE = (255, 255, 255)\nBLUE = (100, 149, 237)\n\n# Define triangle vertices (centered on the screen)\ntriangle_points = [(250, 100), (150, 400), (350, 400)]\n\n# Main loop\nrunning = True\nwhile running:\n    # Handle events\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n\n    # Fill the background\n    screen.fill(WHITE)\n\n    # Draw the triangle\n    pygame.draw.polygon(screen, BLUE, triangle_points)\n\n    # Update the display\n    pygame.display.flip()\n\n# Quit pygame\npygame.quit()\nsys.exit()",
      "steps": [
        {
          "step_1": {
            "code_line": "import pygame",
            "description": "We import the Pygame library to utilize its functionality for graphics."
          }
        },
        {
          "step_2": {
            "code_line": "import sys",
            "description": "We import the sys module to allow the program to exit cleanly."
          }
        },
        {
          "step_3": {
            "code_line": "pygame.init()",
            "description": "We initialize Pygame modules to set up the environment."
          }
        },
        {
          "step_4": {
            "code_line": "screen_width = 500\nscreen_height = 500",
            "description": "We define the dimensions of the display window as 500x500 pixels."
          }
        },
        {
          "step_5": {
            "code_line": "screen = pygame.display.set_mode((screen_width, screen_height))",
            "description": "We create the display window with the specified dimensions."
          }
        },
        {
          "step_6": {
            "code_line": "pygame.display.set_caption('Triangle')",
            "description": "We set the title of the window to 'Triangle' to identify the application."
          }
        },
        {
          "step_7": {
            "code_line": "WHITE = (255, 255, 255)\nBLUE = (100, 149, 237)",
            "description": "We define colors using RGB values for white and blue."
          }
        },
        {
          "step_8": {
            "code_line": "triangle_points = [(250, 100), (150, 400), (350, 400)]",
            "description": "We specify the vertices of the triangle, placing it centered within the window."
          }
        },
        {
          "step_9": {
            "code_line": "while running:",
            "description": "We enter the main loop that keeps the program running."
          }
        },
        {
          "step_10": {
            "code_line": "for event in pygame.event.get():",
            "description": "We process events from the event queue to handle user interactions."
          }
        },
        {
          "step_11": {
            "code_line": "if event.type == pygame.QUIT:",
            "description": "We check for the quit event to allow the user to close the window."
          }
        },
        {
          "step_12": {
            "code_line": "screen.fill(WHITE)",
            "description": "We fill the background with white color before drawing the triangle."
          }
        },
        {
          "step_13": {
            "code_line": "pygame.draw.polygon(screen, BLUE, triangle_points)",
            "description": "We draw the triangle on the screen using the defined blue color and vertices."
          }
        },
        {
          "step_14": {
            "code_line": "pygame.display.flip()",
            "description": "We update the display to show the rendered triangle."
          }
        },
        {
          "step_15": {
            "code_line": "pygame.quit()",
            "description": "We exit Pygame and clean up resources after closing the window."
          }
        },
        {
          "step_16": {
            "code_line": "sys.exit()",
            "description": "We exit the program cleanly."
          }
        }
      ]
    }
  },
  "task_4": {
    "title": "Create a Traffic Light",
    "type": "practical",
    "description": "Write a program to create a visual representation of a traffic light using Pygame.",
    "explanation": {
      "beginner": {
        "title": "What Are We Doing?",
        "content": [
          {
            "tag": "concept",
            "text": "We will draw a traffic light on the screen with three colored lights: red, yellow, and green."
          },
          {
            "tag": "action",
            "text": "The program will set up a display window and render the traffic light using basic shapes."
          },
          {
            "tag": "tool",
            "text": "We'll use the Pygame library to handle graphics and drawing operations."
          }
        ]
      },
      "intermediate": {
        "title": "What's Happening Here?",
        "content": [
          {
            "tag": "goal",
            "text": "Our goal is to create a static representation of a traffic light using rectangles and circles."
          },
          {
            "tag": "color_management",
            "text": "We will define colors using RGB values for the lights and the traffic light frame."
          },
          {
            "tag": "layout",
            "text": "Understanding how to position shapes on the screen using coordinates is crucial."
          }
        ]
      },
      "advanced": {
        "title": "Deep Dive",
        "content": [
          {
            "tag": "graphics_pipeline",
            "text": "Explore how Pygame renders shapes and updates the display efficiently."
          },
          {
            "tag": "event_handling",
            "text": "We will handle user inputs to quit the program gracefully."
          },
          {
            "tag": "performance",
            "text": "Discuss ways to optimize rendering and manage frame rates for smoother graphics."
          }
        ]
      }
    },
    "solution": {
      "code": "import pygame\nimport sys\n\n# Initialize pygame\npygame.init()\n\n# Define colors\nBLACK = (0, 0, 0)\nWHITE = (255, 255, 255)\nRED = (255, 0, 0)\nYELLOW = (255, 255, 0)\nGREEN = (0, 255, 0)\n\n# Set up display\nwidth, height = 200, 600\nscreen = pygame.display.set_mode((width, height))\np pygame.display.set_caption('Traffic Light')\n\n# Set up the clock to control the frame rate\nclock = pygame.time.Clock()\n\ndef draw_traffic_light():\n    # Draw the traffic light frame\n    pygame.draw.rect(screen, BLACK, (50, 50, 100, 500), 5)\n    \n    # Draw the three circles for the lights\n    pygame.draw.circle(screen, RED, (100, 150), 50)     # Red light\n    pygame.draw.circle(screen, YELLOW, (100, 300), 50)  # Yellow light\n    pygame.draw.circle(screen, GREEN, (100, 450), 50)   # Green light\n\ndef main():\n    while True:\n        screen.fill(WHITE)\n\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n\n        draw_traffic_light()\n\n        pygame.display.update()\n        clock.tick(60)\n\nif __name__ == \"__main__\":\n    main()",
      "steps": [
        {
          "step_1": {
            "code_line": "import pygame",
            "description": "We import the Pygame library to use its functionality for graphics."
          }
        },
        {
          "step_2": {
            "code_line": "import sys",
            "description": "We import the sys module to allow the program to exit cleanly."
          }
        },
        {
          "step_3": {
            "code_line": "pygame.init()",
            "description": "We initialize Pygame modules to set up the environment."
          }
        },
        {
          "step_4": {
            "code_line": "BLACK = (0, 0, 0)\nWHITE = (255, 255, 255)\nRED = (255, 0, 0)\nYELLOW = (255, 255, 0)\nGREEN = (0, 255, 0)",
            "description": "We define colors using RGB values for black, white, red, yellow, and green."
          }
        },
        {
          "step_5": {
            "code_line": "width, height = 200, 600\nscreen = pygame.display.set_mode((width, height))",
            "description": "We set the dimensions of the display window to 200x600 pixels."
          }
        },
        {
          "step_6": {
            "code_line": "pygame.display.set_caption('Traffic Light')",
            "description": "We set the title of the window to 'Traffic Light' for identification."
          }
        },
        {
          "step_7": {
            "code_line": "clock = pygame.time.Clock()",
            "description": "We create a clock to control the frame rate of the application."
          }
        },
        {
          "step_8": {
            "code_line": "def draw_traffic_light():",
            "description": "We define a function to draw the traffic light."
          }
        },
        {
          "step_9": {
            "code_line": "pygame.draw.rect(screen, BLACK, (50, 50, 100, 500), 5)",
            "description": "We draw the outer frame of the traffic light using a black rectangle."
          }
        },
        {
          "step_10": {
            "code_line": "pygame.draw.circle(screen, RED, (100, 150), 50)",
            "description": "We draw the red light at the specified coordinates."
          }
        },
        {
          "step_11": {
            "code_line": "pygame.draw.circle(screen, YELLOW, (100, 300), 50)",
            "description": "We draw the yellow light at the specified coordinates."
          }
        },
        {
          "step_12": {
            "code_line": "pygame.draw.circle(screen, GREEN, (100, 450), 50)",
            "description": "We draw the green light at the specified coordinates."
          }
        },
        {
          "step_13": {
            "code_line": "while True:",
            "description": "We enter the main loop that keeps the program running."
          }
        },
        {
          "step_14": {
            "code_line": "for event in pygame.event.get():",
            "description": "We process events from the event queue to handle user interactions."
          }
        },
        {
          "step_15": {
            "code_line": "if event.type == pygame.QUIT:",
            "description": "We check for the quit event to allow the user to close the window."
          }
        },
        {
          "step_16": {
            "code_line": "screen.fill(WHITE)",
            "description": "We fill the background with white color before drawing the traffic light."
          }
        },
        {
          "step_17": {
            "code_line": "draw_traffic_light()",
            "description": "We call the function to draw the traffic light on the screen."
          }
        },
        {
          "step_18": {
            "code_line": "pygame.display.update()",
            "description": "We update the display to show the rendered traffic light."
          }
        },
        {
          "step_19": {
            "code_line": "clock.tick(60)",
            "description": "We control the frame rate of the application, limiting it to 60 frames per second."
          }
        },
        {
          "step_20": {
            "code_line": "pygame.quit()",
            "description": "We exit Pygame and clean up resources after closing the window."
          }
        },
        {
          "step_21": {
            "code_line": "sys.exit()",
            "description": "We exit the program cleanly."
          }
        }
      ]
    }
  },
  "task_5": {
    "title": "Draw Diagonal Circles",
    "type": "practical",
    "description": "Write a program to display red circles diagonally on a 400x400 screen.",
    "explanation": {
      "beginner": {
        "title": "What Are We Doing?",
        "content": [
          {
            "tag": "concept",
            "text": "We will draw red circles that appear diagonally down the screen."
          },
          {
            "tag": "action",
            "text": "The program will utilize a loop to create multiple circles with increasing spacing."
          },
          {
            "tag": "tool",
            "text": "We will use the Pygame library to handle graphics and drawing operations."
          }
        ]
      },
      "intermediate": {
        "title": "What's Happening Here?",
        "content": [
          {
            "tag": "looping",
            "text": "We will use a loop to control how many circles are drawn and their positions."
          },
          {
            "tag": "positioning",
            "text": "Understanding how to position shapes on the screen using coordinates is crucial."
          },
          {
            "tag": "spacing",
            "text": "We will increment the spacing between circles to create a staggered effect."
          }
        ]
      },
      "advanced": {
        "title": "Deep Dive",
        "content": [
          {
            "tag": "graphics_pipeline",
            "text": "Explore how Pygame handles the drawing process for efficiency."
          },
          {
            "tag": "event_handling",
            "text": "We will handle user inputs to quit the program gracefully."
          },
          {
            "tag": "performance",
            "text": "Discuss ways to optimize rendering, especially when drawing multiple shapes."
          }
        ]
      }
    },
    "solution": {
      "code": "import pygame\nimport sys\n\n# Initialize pygame\npygame.init()\n\n# Define colors\nBLACK = (0, 0, 0)\nRED = (255, 0, 0)\n\n# Set up display\nwidth, height = 400, 400\nscreen = pygame.display.set_mode((width, height))\np pygame.display.set_caption('Rounds')\n\n# Set up the clock to control the frame rate\nclock = pygame.time.Clock()\n\ndef draw_circles():\n    # Starting position and initial spacing\n    x, y = 50, 50\n    spacing = 50\n\n    # Draw circles diagonally down the screen\n    for i in range(10):\n        pygame.draw.circle(screen, RED, (x, y), 20)\n        x += spacing\n        y += spacing\n        spacing += 5  # Increment spacing to create the effect\n\ndef main():\n    while True:\n        screen.fill(BLACK)\n\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n\n        draw_circles()\n\n        pygame.display.update()\n        clock.tick(60)\n\nif __name__ == \"__main__\":\n    main()",
      "steps": [
        {
          "step_1": {
            "code_line": "import pygame",
            "description": "We import the Pygame library to use its functionality for graphics."
          }
        },
        {
          "step_2": {
            "code_line": "import sys",
            "description": "We import the sys module to allow the program to exit cleanly."
          }
        },
        {
          "step_3": {
            "code_line": "pygame.init()",
            "description": "We initialize Pygame modules to set up the environment."
          }
        },
        {
          "step_4": {
            "code_line": "BLACK = (0, 0, 0)\nRED = (255, 0, 0)",
            "description": "We define colors using RGB values for black and red."
          }
        },
        {
          "step_5": {
            "code_line": "width, height = 400, 400\nscreen = pygame.display.set_mode((width, height))",
            "description": "We set the dimensions of the display window to 400x400 pixels."
          }
        },
        {
          "step_6": {
            "code_line": "pygame.display.set_caption('Rounds')",
            "description": "We set the title of the window to 'Rounds' for identification."
          }
        },
        {
          "step_7": {
            "code_line": "clock = pygame.time.Clock()",
            "description": "We create a clock to control the frame rate of the application."
          }
        },
        {
          "step_8": {
            "code_line": "def draw_circles():",
            "description": "We define a function to draw the red circles on the screen."
          }
        },
        {
          "step_9": {
            "code_line": "x, y = 50, 50\nspacing = 50",
            "description": "We initialize starting coordinates and spacing for the circles."
          }
        },
        {
          "step_10": {
            "code_line": "for i in range(10):",
            "description": "We use a loop to draw 10 circles on the screen."
          }
        },
        {
          "step_11": {
            "code_line": "pygame.draw.circle(screen, RED, (x, y), 20)",
            "description": "We draw a red circle at the current (x, y) position."
          }
        },
        {
          "step_12": {
            "code_line": "x += spacing\n        y += spacing\n        spacing += 5",
            "description": "We increment the x and y positions and increase the spacing for the next circle."
          }
        },
        {
          "step_13": {
            "code_line": "while True:",
            "description": "We enter the main loop that keeps the program running."
          }
        },
        {
          "step_14": {
            "code_line": "for event in pygame.event.get():",
            "description": "We process events from the event queue to handle user interactions."
          }
        },
        {
          "step_15": {
            "code_line": "if event.type == pygame.QUIT:",
            "description": "We check for the quit event to allow the user to close the window."
          }
        },
        {
          "step_16": {
            "code_line": "screen.fill(BLACK)",
            "description": "We fill the background with black color before drawing the circles."
          }
        },
        {
          "step_17": {
            "code_line": "draw_circles()",
            "description": "We call the function to draw the red circles on the screen."
          }
        },
        {
          "step_18": {
            "code_line": "pygame.display.update()",
            "description": "We update the display to show the rendered circles."
          }
        },
        {
          "step_19": {
            "code_line": "clock.tick(60)",
            "description": "We control the frame rate of the application, limiting it to 60 frames per second."
          }
        },
        {
          "step_20": {
            "code_line": "pygame.quit()",
            "description": "We exit Pygame and clean up resources after closing the window."
          }
        },
        {
          "step_21": {
            "code_line": "sys.exit()",
            "description": "We exit the program cleanly."
          }
        }
      ]
    }
  },
    "task_6": {
      "title": "Color Rain Animation",
      "type": "practical",
      "description": "Write a program to create a colorful rain effect using random lines on a 400x400 screen.",
      "explanation": {
        "beginner": {
          "title": "What Are We Doing?",
          "content": [
            {
              "tag": "concept",
              "text": "We will create an animation that draws multiple colorful lines randomly on the screen."
            },
            {
              "tag": "action",
              "text": "Using loops and random values, we will simulate a rain-like effect."
            },
            {
              "tag": "tool",
              "text": "The Pygame library will be used to handle drawing and displaying graphics."
            }
          ]
        },
        "intermediate": {
          "title": "What's Happening Here?",
          "content": [
            {
              "tag": "randomness",
              "text": "We will use Python's random library to generate random colors and coordinates for the lines."
            },
            {
              "tag": "looping",
              "text": "A loop will help us draw multiple lines in each frame, creating an animated effect."
            },
            {
              "tag": "event_handling",
              "text": "We will handle quit events to allow the user to close the program."
            }
          ]
        },
        "advanced": {
          "title": "Deep Dive",
          "content": [
            {
              "tag": "performance",
              "text": "Discuss how to optimize drawing methods to maintain a smooth frame rate."
            },
            {
              "tag": "animation",
              "text": "Explore more advanced techniques for creating dynamic visual effects."
            },
            {
              "tag": "color theory",
              "text": "Discuss the RGB color model and how random colors can enhance visual interest."
            }
          ]
        }
      },
      "solution": {
        "code": "import pygame\nimport random\nimport sys\n\n# Initialize pygame\npygame.init()\n\n# Define screen size\nwidth, height = 400, 400\nscreen = pygame.display.set_mode((width, height))\np pygame.display.set_caption('Color Rain')\n\n# Set up the clock to control the frame rate\nclock = pygame.time.Clock()\n\ndef draw_random_lines():\n    # Draw a line with random color and random coordinates\n    x1 = random.randint(0, width)\n    y1 = random.randint(0, height)\n    x2 = random.randint(0, width)\n    y2 = random.randint(0, height)\n    \n    # Random color\n    color = (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))\n    \n    # Draw the line\n    pygame.draw.line(screen, color, (x1, y1), (x2, y2), 2)\n\ndef main():\n    while True:\n        # Process events\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n\n        # Draw multiple random lines to create the \"rain\" effect\n        for _ in range(100):  # Increase number of lines for a more dense effect\n            draw_random_lines()\n\n        pygame.display.update()\n        clock.tick(60)  # Keep the frame rate at 60 FPS\n\nif __name__ == \"__main__\":\n    main()",
        "steps": [
          {
            "step_1": {
              "code_line": "import pygame",
              "description": "We import the Pygame library to access its functionalities."
            }
          },
          {
            "step_2": {
              "code_line": "import random",
              "description": "We import the random module to generate random numbers for colors and positions."
            }
          },
          {
            "step_3": {
              "code_line": "import sys",
              "description": "We import the sys module to allow for graceful exits from the program."
            }
          },
          {
            "step_4": {
              "code_line": "pygame.init()",
              "description": "We initialize all the Pygame modules for use."
            }
          },
          {
            "step_5": {
              "code_line": "width, height = 400, 400\nscreen = pygame.display.set_mode((width, height))",
              "description": "We set the size of the display window to 400x400 pixels."
            }
          },
          {
            "step_6": {
              "code_line": "pygame.display.set_caption('Color Rain')",
              "description": "We set the title of the window to 'Color Rain' for identification."
            }
          },
          {
            "step_7": {
              "code_line": "clock = pygame.time.Clock()",
              "description": "We create a clock object to control the frame rate of the application."
            }
          },
          {
            "step_8": {
              "code_line": "def draw_random_lines():",
              "description": "We define a function to draw random lines on the screen."
            }
          },
          {
            "step_9": {
              "code_line": "x1 = random.randint(0, width)\ny1 = random.randint(0, height)\nx2 = random.randint(0, width)\ny2 = random.randint(0, height)",
              "description": "We generate random coordinates for the starting and ending points of the line."
            }
          },
          {
            "step_10": {
              "code_line": "color = (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))",
              "description": "We create a random color by generating random values for red, green, and blue components."
            }
          },
          {
            "step_11": {
              "code_line": "pygame.draw.line(screen, color, (x1, y1), (x2, y2), 2)",
              "description": "We draw a line on the screen using the randomly generated coordinates and color."
            }
          },
          {
            "step_12": {
              "code_line": "while True:",
              "description": "We enter the main loop to keep the program running."
            }
          },
          {
            "step_13": {
              "code_line": "for event in pygame.event.get():",
              "description": "We process events from the event queue, such as user inputs."
            }
          },
          {
            "step_14": {
              "code_line": "if event.type == pygame.QUIT:",
              "description": "We check for the quit event to allow the user to close the window."
            }
          },
          {
            "step_15": {
              "code_line": "for _ in range(100):",
              "description": "We loop 100 times to draw multiple lines, creating a dense effect."
            }
          },
          {
            "step_16": {
              "code_line": "draw_random_lines()",
              "description": "We call the function to draw the random lines on the screen."
            }
          },
          {
            "step_17": {
              "code_line": "pygame.display.update()",
              "description": "We update the display to show the drawn lines."
            }
          },
          {
            "step_18": {
              "code_line": "clock.tick(60)",
              "description": "We limit the frame rate to 60 frames per second for smooth animation."
            }
          },
          {
            "step_19": {
              "code_line": "pygame.quit()",
              "description": "We clean up and close Pygame modules after quitting."
            }
          },
          {
            "step_20": {
              "code_line": "sys.exit()",
              "description": "We exit the program cleanly."
            }
          }
        ]
      }
    },
  "task_7": {
    "title": "Custom Drawing with Pygame",
    "type": "practical",
    "description": "Write a program to create a custom drawing of a person using various graphic primitives.",
    "explanation": {
      "beginner": {
        "title": "What Are We Doing?",
        "content": [
          {
            "tag": "concept",
            "text": "We will create a drawing of a person using basic shapes like rectangles, ellipses, and polygons."
          },
          {
            "tag": "action",
            "text": "By combining these shapes, we can form a simple character representation."
          },
          {
            "tag": "tool",
            "text": "We will use the Pygame library for drawing and displaying our art."
          }
        ]
      },
      "intermediate": {
        "title": "What's Happening Here?",
        "content": [
          {
            "tag": "shapes",
            "text": "Different shapes are drawn to represent various body parts, such as the head, arms, and legs."
          },
          {
            "tag": "color",
            "text": "We will use colors to fill in the shapes and give our drawing a more appealing look."
          },
          {
            "tag": "event_handling",
            "text": "We handle events to allow the user to close the application gracefully."
          }
        ]
      },
      "advanced": {
        "title": "Deep Dive",
        "content": [
          {
            "tag": "design",
            "text": "Explore how to create more complex shapes and add textures or gradients to enhance visual effects."
          },
          {
            "tag": "animation",
            "text": "Consider adding animation to your drawing by updating positions or colors over time."
          },
          {
            "tag": "event_loop",
            "text": "Learn how the main event loop operates and how to optimize drawing for performance."
          }
        ]
      }
    },
    "solution": {
      "code": "import pygame\nimport sys\n\n# Initialize Pygame\npygame.init()\n\n# Set up the display\nwidth, height = 800, 600\nscreen = pygame.display.set_mode((width, height))\np pygame.display.set_caption(\"Person Art\")\n\n# Define colors\nWHITE = (255, 255, 255)\nPINK = (255, 182, 193)\nBLACK = (0, 0, 0)\nYELLOW = (255, 215, 0)\nLIGHT_BLUE = (173, 216, 230)\nDARK_PINK = (255, 105, 180)\nPURPLE = (128, 0, 128)\n\n# Function to draw the character\ndef draw_person():\n    screen.fill(WHITE)  # Fill background with white\n\n    # Draw hair (more detail)\n    pygame.draw.polygon(screen, DARK_PINK, [(400, 100), (460, 150), (400, 130), (340, 150), (400, 100)])  # Hair spikes\n    pygame.draw.polygon(screen, PINK, [(400, 100), (420, 150), (380, 150)])  # Additional spikes\n\n    # Draw face\n    pygame.draw.ellipse(screen, LIGHT_BLUE, (370, 150, 60, 80))  # Face shape\n\n    # Draw eyes\n    pygame.draw.ellipse(screen, BLACK, (385, 175, 10, 20))  # Left eye\n    pygame.draw.ellipse(screen, BLACK, (405, 175, 10, 20))  # Right eye\n    pygame.draw.ellipse(screen, WHITE, (387, 180, 5, 10))  # Left eye highlight\n    pygame.draw.ellipse(screen, WHITE, (407, 180, 5, 10))  # Right eye highlight\n\n    # Draw mouth\n    pygame.draw.arc(screen, BLACK, (385, 210, 30, 20), 0, 3.14, 2)  # Mouth\n\n    # Draw body\n    pygame.draw.rect(screen, PINK, (385, 230, 30, 80))  # Body\n\n    # Draw arms (with some curvature for the arms)\n    pygame.draw.rect(screen, PINK, (360, 230, 25, 70))  # Left arm\n    pygame.draw.rect(screen, PINK, (415, 230, 25, 70))  # Right arm\n    pygame.draw.arc(screen, PINK, (360, 230, 25, 70), 0, 3.14, 5)  # Curve for left arm\n    pygame.draw.arc(screen, PINK, (415, 230, 25, 70), 0, 3.14, 5)  # Curve for right arm\n\n    # Draw legs\n    pygame.draw.rect(screen, PINK, (385, 310, 10, 60))  # Left leg\n    pygame.draw.rect(screen, PINK, (395, 310, 10, 60))  # Right leg\n\n    # Draw shoes\n    pygame.draw.rect(screen, BLACK, (385, 370, 10, 10))  # Left shoe\n    pygame.draw.rect(screen, BLACK, (395, 370, 10, 10))  # Right shoe\n\n    # Draw details (like clothing)\n    pygame.draw.rect(screen, YELLOW, (370, 230, 60, 10))  # Collar\n    pygame.draw.rect(screen, PURPLE, (385, 230, 30, 10))  # Belt\n\n# Main loop\nwhile True:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n\n    draw_person()\n    pygame.display.flip()  # Update the display",
      "steps": [
        {
          "step_1": {
            "code_line": "import pygame",
            "description": "We import the Pygame library to use its graphics capabilities."
          }
        },
        {
          "step_2": {
            "code_line": "import sys",
            "description": "We import the sys module to handle system-level functions."
          }
        },
        {
          "step_3": {
            "code_line": "pygame.init()",
            "description": "We initialize all Pygame modules for our application."
          }
        },
        {
          "step_4": {
            "code_line": "width, height = 800, 600\nscreen = pygame.display.set_mode((width, height))",
            "description": "We set the display dimensions to 800x600 pixels."
          }
        },
        {
          "step_5": {
            "code_line": "pygame.display.set_caption(\"Person Art\")",
            "description": "We set the title of the window to 'Person Art'."
          }
        },
        {
          "step_6": {
            "code_line": "WHITE = (255, 255, 255)\nPINK = (255, 182, 193)\nBLACK = (0, 0, 0)\nYELLOW = (255, 215, 0)\nLIGHT_BLUE = (173, 216, 230)\nDARK_PINK = (255, 105, 180)\nPURPLE = (128, 0, 128)",
            "description": "We define colors using RGB values for use in our drawing."
          }
        },
        {
          "step_7": {
            "code_line": "def draw_person():",
            "description": "We define a function to draw the person character on the screen."
          }
        },
        {
          "step_8": {
            "code_line": "screen.fill(WHITE)",
            "description": "We fill the background with white color."
          }
        },
        {
          "step_9": {
            "code_line": "pygame.draw.polygon(screen, DARK_PINK, [...])",
            "description": "We draw the character's hair using polygons for a spiky effect."
          }
        },
        {
          "step_10": {
            "code_line": "pygame.draw.ellipse(screen, LIGHT_BLUE, (370, 150, 60, 80))",
            "description": "We draw the face shape using an ellipse."
          }
        },
        {
          "step_11": {
            "code_line": "pygame.draw.ellipse(screen, BLACK, (385, 175, 10, 20))",
            "description": "We draw the eyes using ellipses."
          }
        },
        {
          "step_12": {
            "code_line": "pygame.draw.arc(screen, BLACK, (385, 210, 30, 20), 0, 3.14, 2)",
            "description": "We draw the mouth using an arc to create a smile."
          }
        },
        {
          "step_13": {
            "code_line": "pygame.draw.rect(screen, PINK, (385, 230, 30, 80))",
            "description": "We draw the body using a rectangle."
          }
        },
        {
          "step_14": {
            "code_line": "pygame.draw.rect(screen, PINK, (360, 230, 25, 70))",
            "description": "We draw the arms using rectangles."
          }
        },
        {
          "step_15": {
            "code_line": "pygame.draw.rect(screen, PINK, (385, 310, 10, 60))",
            "description": "We draw the legs using rectangles."
          }
        },
        {
          "step_16": {
            "code_line": "pygame.draw.rect(screen, BLACK, (385, 370, 10, 10))",
            "description": "We draw the shoes using rectangles."
          }
        },
        {
          "step_17": {
            "code_line": "pygame.display.flip()",
            "description": "We update the display to show our drawing."
          }
        }
      ]
    }
  }
        }
    },
    "5": {
        "title": "PyGame. Surfaces. Animation and Time",
        "tasks": {
            "task_1": {
    "title": "Understanding Pygame Surfaces and Animation",
    "type": "theoretical",
    "description": "Learn about Pygame surfaces and how to implement time and animation in your projects.",
    "resources": [
      {
        "title": "Pygame Surfaces",
        "link": "https://www.bzfar.org/publ/algorithms_programming/algorithms/python_pygame_surfaces/56-1-0-208",
        "description": "An introduction to Pygame surfaces, their properties, and how to use them for drawing."
      },
      {
        "title": "Pygame Time and Animation",
        "link": "https://www.bzfar.org/publ/algorithms_programming/algorithms/python_pygame_time_and_animation/56-1-0-211",
        "description": "Learn how to manage time and create animations in Pygame."
      }
    ],
    "theory": {
      "Pygame Surfaces": {
        "definition": "A surface is a 2D array of pixels that can be used to represent images or drawings. Surfaces are essential for rendering graphics in Pygame.",
        "key_points": [
          {
            "point": "Creating Surfaces",
            "details": "You can create a new surface using `pygame.Surface(width, height)`, where width and height are in pixels."
          },
          {
            "point": "Blitting Surfaces",
            "details": "To draw a surface on another surface (like the main screen), use the `blit()` method. This allows for layering images and drawings."
          },
          {
            "point": "Surface Properties",
            "details": "Surfaces can have different pixel formats, color depths, and can be filled with colors or images using methods like `fill()` and `blit()`."
          }
        ]
      },
      "Animation in Pygame": {
        "definition": "Animation involves changing the properties of surfaces over time to create the illusion of movement.",
        "key_points": [
          {
            "point": "Frame Rate",
            "details": "Control the speed of your animation using the `pygame.time.Clock` class to manage frame rates. Call `tick(fps)` to limit the frames per second."
          },
          {
            "point": "Updating Surfaces",
            "details": "Update the display by continuously redrawing surfaces in a loop. This can create various effects like movement, fading, and more."
          },
          {
            "point": "Event Handling",
            "details": "Handle events (like key presses) to trigger animations or changes in your program. Use the event loop to manage user interactions."
          }
        ]
      }
    },
    "explanation": {
      "beginner": {
        "title": "Getting Started with Surfaces",
        "content": [
          {
            "tag": "concept",
            "text": "Surfaces are the building blocks for all graphics in Pygame."
          },
          {
            "tag": "action",
            "text": "You will create and manipulate surfaces to display images and shapes."
          }
        ]
      },
      "intermediate": {
        "title": "Using Surfaces and Animation",
        "content": [
          {
            "tag": "technique",
            "text": "Learn how to animate objects on the screen by updating their positions over time."
          },
          {
            "tag": "application",
            "text": "Understanding how to use surfaces will enhance your ability to create more complex graphics and animations."
          }
        ]
      },
      "advanced": {
        "title": "Optimizing Graphics and Animation",
        "content": [
          {
            "tag": "optimization",
            "text": "Explore techniques to optimize rendering performance by minimizing redraws and using surface caching."
          },
          {
            "tag": "advanced_concepts",
            "text": "Learn about sprite groups for managing multiple animated objects efficiently."
          }
        ]
      }
    }
  },
  "task_2": {
    "title": "Drawing the Japanese Flag",
    "type": "practical",
    "description": "Write a program to create a game window of size 600x400 pixels and output the Japanese flag.",
    "explanation": {
      "beginner": {
        "title": "What Are We Doing?",
        "content": [
          {
            "tag": "concept",
            "text": "We will create a game window where we can draw graphics."
          },
          {
            "tag": "action",
            "text": "We will draw the Japanese flag using basic shapes and colors."
          }
        ]
      },
      "intermediate": {
        "title": "What's Happening Here?",
        "content": [
          {
            "tag": "background",
            "text": "The window will be filled with a white background to represent the flag's base."
          },
          {
            "tag": "shape",
            "text": "A red circle will be drawn in the center to represent the sun, following the design of the Japanese flag."
          }
        ]
      },
      "advanced": {
        "title": "Deep Dive",
        "content": [
          {
            "tag": "surfaces",
            "text": "Understand how Pygame manages surfaces and draws shapes."
          },
          {
            "tag": "performance",
            "text": "Explore how to optimize drawing operations for better performance in larger applications."
          }
        ]
      }
    },
    "solution": {
      "code": "import pygame\nimport sys\n\n# Initialize Pygame\npygame.init()\n\n# Set up the display\nscreen = pygame.display.set_mode((600, 400))\np pygame.display.set_caption('Japanese Flag')\n\n# Define colors\nwhite = (255, 255, 255)\nred = (188, 0, 45)\n\n# Main loop\nrunning = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n\n    # Fill the background with white\n    screen.fill(white)\n\n    # Draw the red circle\n    pygame.draw.circle(screen, red, (300, 200), 100)\n\n    # Update the display\n    pygame.display.flip()",
      "steps": [
        {
          "step_1": {
            "code_line": "import pygame",
            "description": "We import the Pygame library to use its graphics capabilities."
          }
        },
        {
          "step_2": {
            "code_line": "import sys",
            "description": "We import the sys module to handle system-level functions."
          }
        },
        {
          "step_3": {
            "code_line": "pygame.init()",
            "description": "We initialize all Pygame modules for our application."
          }
        },
        {
          "step_4": {
            "code_line": "screen = pygame.display.set_mode((600, 400))",
            "description": "We set the display dimensions to 600x400 pixels."
          }
        },
        {
          "step_5": {
            "code_line": "pygame.display.set_caption('Japanese Flag')",
            "description": "We set the title of the window to 'Japanese Flag'."
          }
        },
        {
          "step_6": {
            "code_line": "running = True",
            "description": "We create a flag to control the main loop."
          }
        },
        {
          "step_7": {
            "code_line": "screen.fill(white)",
            "description": "We fill the background with white color."
          }
        },
        {
          "step_8": {
            "code_line": "pygame.draw.circle(screen, red, (300, 200), 100)",
            "description": "We draw the red circle in the center of the screen."
          }
        },
        {
          "step_9": {
            "code_line": "pygame.display.flip()",
            "description": "We update the display to show our drawing."
          }
        },
        {
          "step_10": {
            "code_line": "for event in pygame.event.get():",
            "description": "We check for events to handle user interactions."
          }
        },
        {
          "step_11": {
            "code_line": "if event.type == pygame.QUIT:",
            "description": "We check if the user wants to close the window."
          }
        },
        {
          "step_12": {
            "code_line": "pygame.quit()",
            "description": "We clean up Pygame resources."
          }
        },
        {
          "step_13": {
            "code_line": "sys.exit()",
            "description": "We exit the program."
          }
        }
      ]
    }
  },
    "task_3": {
      "title": "Animation - 1",
      "type": "practical",
      "description": "Develop a program in which the green circle moves from right to left along the lower border. The circle stops in front of the left border and changes color to red.",
      "explanation": {
        "beginner": {
          "title": "What Are We Doing?",
          "content": [
            {
              "tag": "concept",
              "text": "We will create a window where a circle moves across the screen."
            },
            {
              "tag": "action",
              "text": "The circle will start green and change to red when it reaches the left edge."
            },
            {
              "tag": "tool",
              "text": "We will use Pygame to manage the graphics and animation."
            }
          ]
        },
        "intermediate": {
          "title": "What's Happening Here?",
          "content": [
            {
              "tag": "movement",
              "text": "The circle's position is updated in each frame of the game loop."
            },
            {
              "tag": "color_change",
              "text": "We check if the circle has reached the left edge to change its color."
            },
            {
              "tag": "frame_rate",
              "text": "We use a clock to control the frame rate of the animation."
            }
          ]
        },
        "advanced": {
          "title": "Deep Dive",
          "content": [
            {
              "tag": "performance",
              "text": "Explore ways to optimize the animation loop for smoother performance."
            },
            {
              "tag": "events",
              "text": "Learn how to handle user inputs and integrate them into your animation."
            },
            {
              "tag": "shapes",
              "text": "Understand how to draw different shapes and use them in animations."
            }
          ]
        }
      },
      "solution": {
        "code": "import pygame\nimport sys\n\n# Initialize Pygame\npygame.init()\n\n# Set up the display\nwidth, height = 800, 600\nscreen = pygame.display.set_mode((width, height))\np pygame.display.set_caption(\"Pygame Window\")\n\n# Define colors\ngreen = (0, 255, 0)\nred = (255, 0, 0)\n\n# Circle properties\ncircle_radius = 20\ncircle_x = width - circle_radius\ncircle_y = height - circle_radius\ncircle_color = green\ncircle_speed = 5\n\n# Main game loop\nrunning = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n\n    # Move the circle\n    if circle_x > circle_radius:\n        circle_x -= circle_speed\n    else:\n        circle_color = red\n\n    # Fill the screen with black\n    screen.fill((0, 0, 0))\n\n    # Draw the circle\n    pygame.draw.circle(screen, circle_color, (circle_x, circle_y), circle_radius)\n\n    # Update the display\n    pygame.display.flip()\n\n    # Cap the frame rate\n    pygame.time.Clock().tick(60)",
        "steps": [
          {
            "step_1": {
              "code_line": "import pygame",
              "description": "We import the Pygame library to use its graphics capabilities."
            }
          },
          {
            "step_2": {
              "code_line": "import sys",
              "description": "We import the sys module to handle system-level functions."
            }
          },
          {
            "step_3": {
              "code_line": "pygame.init()",
              "description": "We initialize all Pygame modules for our application."
            }
          },
          {
            "step_4": {
              "code_line": "screen = pygame.display.set_mode((width, height))",
              "description": "We set the display dimensions to 800x600 pixels."
            }
          },
          {
            "step_5": {
              "code_line": "pygame.display.set_caption('Pygame Window')",
              "description": "We set the title of the window to 'Pygame Window'."
            }
          },
          {
            "step_6": {
              "code_line": "circle_radius = 20",
              "description": "We define the radius of the circle."
            }
          },
          {
            "step_7": {
              "code_line": "circle_x = width - circle_radius",
              "description": "We set the initial X position of the circle at the right edge."
            }
          },
          {
            "step_8": {
              "code_line": "circle_y = height - circle_radius",
              "description": "We set the Y position of the circle at the bottom of the window."
            }
          },
          {
            "step_9": {
              "code_line": "circle_color = green",
              "description": "We define the initial color of the circle as green."
            }
          },
          {
            "step_10": {
              "code_line": "circle_speed = 5",
              "description": "We define the speed at which the circle moves."
            }
          },
          {
            "step_11": {
              "code_line": "while running:",
              "description": "We start the main game loop."
            }
          },
          {
            "step_12": {
              "code_line": "for event in pygame.event.get():",
              "description": "We check for events to handle user interactions."
            }
          },
          {
            "step_13": {
              "code_line": "if event.type == pygame.QUIT:",
              "description": "We check if the user wants to close the window."
            }
          },
          {
            "step_14": {
              "code_line": "circle_x -= circle_speed",
              "description": "We move the circle to the left by subtracting the speed from its X position."
            }
          },
          {
            "step_15": {
              "code_line": "circle_color = red",
              "description": "We change the color of the circle to red when it reaches the left edge."
            }
          },
          {
            "step_16": {
              "code_line": "screen.fill((0, 0, 0))",
              "description": "We fill the screen with black to clear the previous frame."
            }
          },
          {
            "step_17": {
              "code_line": "pygame.draw.circle(screen, circle_color, (circle_x, circle_y), circle_radius)",
              "description": "We draw the circle on the screen."
            }
          },
          {
            "step_18": {
              "code_line": "pygame.display.flip()",
              "description": "We update the display to show our drawing."
            }
          },
          {
            "step_19": {
              "code_line": "pygame.time.Clock().tick(60)",
              "description": "We cap the frame rate at 60 frames per second."
            }
          }
        ]
      }
    },
  "task_4": {
    "title": "Animation - 2",
    "type": "practical",
    "description": "Modify the Animation - 1 task program so that the green circle moves cyclically from right to left and left to right, creating the effect of rebounding from the walls of the window.",
    "explanation": {
      "beginner": {
        "title": "What Are We Doing?",
        "content": [
          {
            "tag": "concept",
            "text": "We will enhance the previous program to make the circle move back and forth."
          },
          {
            "tag": "action",
            "text": "The circle will bounce off the walls of the window."
          },
          {
            "tag": "tool",
            "text": "We will still use Pygame for graphics and animations."
          }
        ]
      },
      "intermediate": {
        "title": "What's Happening Here?",
        "content": [
          {
            "tag": "movement",
            "text": "The circle's position updates based on its speed and direction."
          },
          {
            "tag": "collision_detection",
            "text": "We check if the circle hits the window borders to reverse its direction."
          },
          {
            "tag": "frame_rate",
            "text": "We continue using a clock to maintain a consistent animation speed."
          }
        ]
      },
      "advanced": {
        "title": "Deep Dive",
        "content": [
          {
            "tag": "performance",
            "text": "Explore optimizing the rendering and movement calculations."
          },
          {
            "tag": "game_logic",
            "text": "Learn how to implement more complex movements and animations."
          },
          {
            "tag": "interaction",
            "text": "Understand how to make the circle respond to user inputs for more dynamic interactions."
          }
        ]
      }
    },
    "solution": {
      "code": "import pygame\nimport sys\n\n# Initialize Pygame\npygame.init()\n\n# Set up the display\nwidth, height = 800, 600\nscreen = pygame.display.set_mode((width, height))\np pygame.display.set_caption(\"Pygame Window\")\n\n# Define colors\ngreen = (0, 255, 0)\nred = (255, 0, 0)\n\n# Circle properties\ncircle_radius = 20\ncircle_x = width // 2\ncircle_y = height - circle_radius\ncircle_color = green\ncircle_speed = 5\ndirection = 1  # 1 for right, -1 for left\n\n# Main game loop\nrunning = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n\n    # Move the circle\n    circle_x += circle_speed * direction\n\n    # Check for collision with borders and reverse direction\n    if circle_x >= width - circle_radius or circle_x <= circle_radius:\n        direction *= -1\n\n    # Fill the screen with black\n    screen.fill((0, 0, 0))\n\n    # Draw the circle\n    pygame.draw.circle(screen, circle_color, (circle_x, circle_y), circle_radius)\n\n    # Update the display\n    pygame.display.flip()\n\n    # Cap the frame rate\n    pygame.time.Clock().tick(60)",
      "steps": [
        {
          "step_1": {
            "code_line": "import pygame",
            "description": "We import the Pygame library for graphical capabilities."
          }
        },
        {
          "step_2": {
            "code_line": "import sys",
            "description": "We import the sys module for handling system-level functions."
          }
        },
        {
          "step_3": {
            "code_line": "pygame.init()",
            "description": "We initialize all Pygame modules for our program."
          }
        },
        {
          "step_4": {
            "code_line": "screen = pygame.display.set_mode((width, height))",
            "description": "We create a display window of size 800x600 pixels."
          }
        },
        {
          "step_5": {
            "code_line": "pygame.display.set_caption('Pygame Window')",
            "description": "We set the window title to 'Pygame Window'."
          }
        },
        {
          "step_6": {
            "code_line": "circle_radius = 20",
            "description": "We define the radius of the circle."
          }
        },
        {
          "step_7": {
            "code_line": "circle_x = width // 2",
            "description": "We initialize the X position of the circle at the center of the window."
          }
        },
        {
          "step_8": {
            "code_line": "circle_y = height - circle_radius",
            "description": "We set the Y position of the circle at the bottom of the window."
          }
        },
        {
          "step_9": {
            "code_line": "circle_color = green",
            "description": "We define the initial color of the circle as green."
          }
        },
        {
          "step_10": {
            "code_line": "circle_speed = 5",
            "description": "We set the speed at which the circle moves."
          }
        },
        {
          "step_11": {
            "code_line": "direction = 1",
            "description": "We initialize the direction of movement (1 for right, -1 for left)."
          }
        },
        {
          "step_12": {
            "code_line": "while running:",
            "description": "We start the main game loop."
          }
        },
        {
          "step_13": {
            "code_line": "for event in pygame.event.get():",
            "description": "We check for events to handle user interactions."
          }
        },
        {
          "step_14": {
            "code_line": "if event.type == pygame.QUIT:",
            "description": "We check if the user wants to close the window."
          }
        },
        {
          "step_15": {
            "code_line": "circle_x += circle_speed * direction",
            "description": "We update the circle's position based on its speed and direction."
          }
        },
        {
          "step_16": {
            "code_line": "if circle_x >= width - circle_radius or circle_x <= circle_radius:",
            "description": "We check if the circle hits the left or right edges of the window."
          }
        },
        {
          "step_17": {
            "code_line": "direction *= -1",
            "description": "We reverse the direction of the circle when it hits a wall."
          }
        },
        {
          "step_18": {
            "code_line": "screen.fill((0, 0, 0))",
            "description": "We fill the screen with black to clear the previous frame."
          }
        },
        {
          "step_19": {
            "code_line": "pygame.draw.circle(screen, circle_color, (circle_x, circle_y), circle_radius)",
            "description": "We draw the circle on the screen at its updated position."
          }
        },
        {
          "step_20": {
            "code_line": "pygame.display.flip()",
            "description": "We update the display to show our drawing."
          }
        },
        {
          "step_21": {
            "code_line": "pygame.time.Clock().tick(60)",
            "description": "We cap the frame rate at 60 frames per second."
          }
        }
      ]
    }
  },
  "task_5": {
    "title": "Animation - 3. Transportation",
    "type": "practical",
    "description": "Write a program to emulate shipping in a square game window. An unfilled square (without a load) moves diagonally from the upper left corner to the lower right corner. Reaching the lower right corner, it moves in the opposite direction, but already painted over (with a load). Add a circle, which will decrease in radius every time you 'transport cargo'. Add a condition under which the end of the 'transportation' will be marked with a yellow color on the screen.",
    "explanation": {
      "beginner": {
        "title": "Understanding the Program",
        "content": [
          {
            "tag": "movement",
            "text": "We will create a square that moves diagonally across the window."
          },
          {
            "tag": "color_change",
            "text": "The square will change color once it reaches the destination."
          },
          {
            "tag": "circle",
            "text": "We will include a circle that shrinks when cargo is transported."
          }
        ]
      },
      "intermediate": {
        "title": "What Happens in This Code?",
        "content": [
          {
            "tag": "logic",
            "text": "The square moves until it hits the borders, then reverses direction."
          },
          {
            "tag": "conditionals",
            "text": "We check the square's position to decide its next move."
          },
          {
            "tag": "graphics",
            "text": "Both the square and circle are drawn on the screen every frame."
          }
        ]
      },
      "advanced": {
        "title": "Going Deeper",
        "content": [
          {
            "tag": "optimization",
            "text": "Explore ways to optimize drawing operations."
          },
          {
            "tag": "game_design",
            "text": "Consider how to add more features or interactions."
          },
          {
            "tag": "refactoring",
            "text": "Learn how to structure code better for readability and maintenance."
          }
        ]
      }
    },
    "solution": {
      "code": "import pygame\nimport sys\n\n# Initialize Pygame\npygame.init()\n\n# Set up the display\nwidth, height = 800, 600\nscreen = pygame.display.set_mode((width, height))\np pygame.display.set_caption(\"Pygame Animation\")\n\n# Define colors\ngreen = (0, 255, 0)\nred = (255, 0, 0)\nblack = (0, 0, 0)\n\n# Square properties\nsquare_size = 50\nsquare_x = 0\nsquare_y = 0\nsquare_color = green\nsquare_speed = 5\n\n# Circle properties\ncircle_radius = 50\ncircle_x = width // 2\ncircle_y = height // 2\ncircle_color = red\n\n# Main game loop\nrunning = True\nmoving_down = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n\n    # Move the square\n    if moving_down:\n        square_x += square_speed\n        square_y += square_speed\n        if square_x >= width - square_size or square_y >= height - square_size:\n            moving_down = False\n            square_color = red\n            circle_radius = max(10, circle_radius - 10)  # Decrease circle radius but not below 10\n    else:\n        square_x -= square_speed\n        square_y -= square_speed\n        if square_x <= 0 or square_y <= 0:\n            moving_down = True\n            square_color = green\n\n    # Fill the screen with black\n    screen.fill(black)\n\n    # Draw the square\n    pygame.draw.rect(screen, square_color, (square_x, square_y, square_size, square_size))\n\n    # Draw the circle\n    pygame.draw.circle(screen, circle_color, (circle_x, circle_y), circle_radius)\n\n    # Update the display\n    pygame.display.flip()\n\n    # Cap the frame rate\n    pygame.time.Clock().tick(60)",
      "steps": [
        {
          "step_1": {
            "code_line": "import pygame",
            "description": "Import the Pygame library for graphical capabilities."
          }
        },
        {
          "step_2": {
            "code_line": "import sys",
            "description": "Import the sys module for handling system-level functions."
          }
        },
        {
          "step_3": {
            "code_line": "pygame.init()",
            "description": "Initialize all Pygame modules for the program."
          }
        },
        {
          "step_4": {
            "code_line": "screen = pygame.display.set_mode((width, height))",
            "description": "Create a display window of size 800x600 pixels."
          }
        },
        {
          "step_5": {
            "code_line": "pygame.display.set_caption('Pygame Animation')",
            "description": "Set the window title to 'Pygame Animation'."
          }
        },
        {
          "step_6": {
            "code_line": "square_size = 50",
            "description": "Define the size of the square."
          }
        },
        {
          "step_7": {
            "code_line": "square_x = 0",
            "description": "Initialize the X position of the square at the top left corner."
          }
        },
        {
          "step_8": {
            "code_line": "square_y = 0",
            "description": "Initialize the Y position of the square at the top left corner."
          }
        },
        {
          "step_9": {
            "code_line": "square_color = green",
            "description": "Set the initial color of the square to green."
          }
        },
        {
          "step_10": {
            "code_line": "square_speed = 5",
            "description": "Define the speed of the square's movement."
          }
        },
        {
          "step_11": {
            "code_line": "circle_radius = 50",
            "description": "Initialize the radius of the circle."
          }
        },
        {
          "step_12": {
            "code_line": "circle_x = width // 2",
            "description": "Position the circle at the center of the window."
          }
        },
        {
          "step_13": {
            "code_line": "circle_y = height // 2",
            "description": "Position the circle at the center of the window."
          }
        },
        {
          "step_14": {
            "code_line": "circle_color = red",
            "description": "Set the initial color of the circle to red."
          }
        },
        {
          "step_15": {
            "code_line": "while running:",
            "description": "Start the main game loop."
          }
        },
        {
          "step_16": {
            "code_line": "for event in pygame.event.get():",
            "description": "Check for events to handle user interactions."
          }
        },
        {
          "step_17": {
            "code_line": "if event.type == pygame.QUIT:",
            "description": "Check if the user wants to close the window."
          }
        },
        {
          "step_18": {
            "code_line": "square_x += square_speed",
            "description": "Move the square diagonally downwards."
          }
        },
        {
          "step_19": {
            "code_line": "square_y += square_speed",
            "description": "Move the square diagonally downwards."
          }
        },
        {
          "step_20": {
            "code_line": "if square_x >= width - square_size or square_y >= height - square_size:",
            "description": "Check if the square has reached the bottom right corner."
          }
        },
        {
          "step_21": {
            "code_line": "moving_down = False",
            "description": "Reverse the direction of the square."
          }
        },
        {
          "step_22": {
            "code_line": "square_color = red",
            "description": "Change the square's color to red after transporting cargo."
          }
        },
        {
          "step_23": {
            "code_line": "circle_radius = max(10, circle_radius - 10)",
            "description": "Decrease the circle's radius but not below 10."
          }
        },
        {
          "step_24": {
            "code_line": "if square_x <= 0 or square_y <= 0:",
            "description": "Check if the square has reached the top left corner."
          }
        },
        {
          "step_25": {
            "code_line": "moving_down = True",
            "description": "Reverse the direction of the square back to downwards."
          }
        },
        {
          "step_26": {
            "code_line": "screen.fill(black)",
            "description": "Fill the screen with black to clear the previous frame."
          }
        },
        {
          "step_27": {
            "code_line": "pygame.draw.rect(screen, square_color, (square_x, square_y, square_size, square_size))",
            "description": "Draw the square on the screen."
          }
        },
        {
          "step_28": {
            "code_line": "pygame.draw.circle(screen, circle_color, (circle_x, circle_y), circle_radius)",
            "description": "Draw the circle on the screen."
          }
        },
        {
          "step_29": {
            "code_line": "pygame.display.flip()",
            "description": "Update the display to show the current frame."
          }
        },
        {
          "step_30": {
            "code_line": "pygame.time.Clock().tick(60)",
            "description": "Limit the frame rate to 60 frames per second."
          }
        }
      ]
    }
  },
  "task_6": {
    "title": "Loading and Animating Pictures in Pygame",
    "type":"theoretical",
    "description": "Pygame is a powerful library for creating games and multimedia applications in Python. Understanding the syntax for loading and animating images is essential for beginners as it lays the groundwork for more complex game development concepts.",
    "key_points": [
      {
        "title": "Loading Images",
        "details": "In Pygame, loading an image is typically done using the `pygame.image.load()` function. The syntax requires the file path to the image and supports various formats like PNG and JPEG. Proper path specification is critical, as incorrect paths will result in errors, preventing the image from loading."
      },
      {
        "title": "Displaying Images",
        "details": "After loading an image, you can display it on the screen using the `blit()` method. The syntax `screen.blit(image, (x, y))` allows for precise placement of the image in the game window. Understanding coordinate systems (origin at the top-left corner) is crucial for positioning images correctly."
      },
      {
        "title": "Animating Images",
        "details": "Animation in Pygame involves updating the position or appearance of images within a game loop. This is typically done by modifying the coordinates of the images based on user input or game logic. Proper syntax for updating the display at each frame is essential to create smooth animations and transitions."
      },
      {
        "title": "Handling Multiple Frames",
        "details": "For animations involving multiple frames (like character sprites), you will often load multiple images and cycle through them in the game loop. Understanding how to use lists or dictionaries to manage these frames is important for creating dynamic animations."
      },
      {
        "title": "Syntax Errors and Debugging",
        "details": "Beginners may encounter syntax errors if they misuse functions or forget required parameters. Learning to read error messages and debug code effectively is a vital skill. Using comments and organizing code logically can help prevent these issues."
      },
      {
        "title": "Best Practices",
        "details": "It’s advisable to load all images at the start of your program to minimize lag during gameplay. Additionally, using image optimization techniques (like reducing resolution or compressing files) can improve performance. Following naming conventions for images can also aid in maintaining a clean codebase."
      },
      {
        "title": "Enhancing Game Dynamics",
        "details": "Mastering the syntax for loading and animating images allows beginners to add dynamic elements to their games, such as moving characters, animated backgrounds, and interactive objects. These elements significantly enhance the player experience and engagement."
      },
      {
        "title": "Transition Effects",
        "details": "Beyond basic animations, Pygame supports various transition effects, such as fading in/out or sliding images. Understanding the syntax for blending colors and using alpha transparency can add a professional touch to game graphics."
      }
    ],
    "conclusion": "Understanding the syntax involved in loading and animating pictures in Pygame is essential for beginners. It not only enables the creation of visually engaging games but also builds a solid foundation for mastering more advanced programming concepts. Mastery of these basics can lead to greater creativity and innovation in game design.",
    "link": "https://www.bzfar.org/publ/algorithms_programming/algorithms/python_pygame_loading_and_animation_pictures/56-1-0-214"
  },
    "task_7": {
      "title": "Background",
      "type": "practical",
      "description": "Using the capabilities of the Draw module, write a function to create a background with roads.",
      "explanation": {
        "beginner": {
          "title": "What Are We Doing?",
          "content": [
            {
              "tag": "concept",
              "text": "We will create a background for our game using Pygame's Draw module to draw roads."
            },
            {
              "tag": "action",
              "text": "By filling the background with a color and drawing rectangles, we can simulate a simple road layout."
            },
            {
              "tag": "tool",
              "text": "Pygame provides various drawing functions, which are useful for creating visual elements in a game."
            }
          ]
        },
        "intermediate": {
          "title": "What's Happening Here?",
          "content": [
            {
              "tag": "drawing",
              "text": "We use the draw.rect function to create both the road and the dashed lines that represent lane markings."
            },
            {
              "tag": "color",
              "text": "Different colors are defined using RGB values, which are essential for creating visually appealing graphics."
            },
            {
              "tag": "modularity",
              "text": "The drawing logic is encapsulated in a function, making it easy to reuse or modify the road drawing logic."
            }
          ]
        },
        "advanced": {
          "title": "Deep Dive",
          "content": [
            {
              "tag": "performance",
              "text": "Understanding how to optimize drawing calls can improve performance, especially with more complex backgrounds."
            },
            {
              "tag": "design",
              "text": "Consider how road design and layout can impact gameplay and player experience, encouraging you to think critically about design choices."
            },
            {
              "tag": "dynamic backgrounds",
              "text": "Explore how to create backgrounds that change based on game events, adding depth and immersion to the game."
            }
          ]
        }
      },
      "solution": {
        "code": "import pygame\n\n# Initialize Pygame\npygame.init()\n\n# Set the dimensions of the window\nwidth, height = 800, 600\nscreen = pygame.display.set_mode((width, height))\n\n# Define colors\nGREEN = (0, 128, 0)\nBLACK = (0, 0, 0)\nWHITE = (255, 255, 255)\n\n# Fill background with green color\nscreen.fill(GREEN)\n\n# Function to draw roads with dashed lines\ndef draw_road(y_position):\n    road_height = 40\n    dash_length = 20\n    \n    # Draw the road rectangle\n    pygame.draw.rect(screen, BLACK, [0, y_position - road_height // 2, width, road_height])\n    \n    # Draw dashed lines on the road\n    for x in range(0, width, dash_length * 2):\n        pygame.draw.rect(screen, WHITE, [x, y_position, dash_length, 5])\n\n# Y positions for each of the five roads based on window height\nroad_positions = [height * i / 6 for i in range(1, 6)]\n\nfor pos in road_positions:\n    draw_road(pos)\n\n# Update display to show changes\npygame.display.flip()\n\n# Main loop to keep the window open\nrunning = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n\npygame.quit()",
        "steps": [
          {
            "step_1": {
              "code_line": "import pygame",
              "description": "We import the Pygame library to use its functions for creating graphics."
            }
          },
          {
            "step_2": {
              "code_line": "pygame.init()",
              "description": "We initialize all Pygame modules necessary for our application."
            }
          },
          {
            "step_3": {
              "code_line": "screen = pygame.display.set_mode((width, height))",
              "description": "We set up the game window dimensions to 800x600 pixels."
            }
          },
          {
            "step_4": {
              "code_line": "screen.fill(GREEN)",
              "description": "We fill the background with a green color to represent grass."
            }
          },
          {
            "step_5": {
              "code_line": "def draw_road(y_position):",
              "description": "We define a function to draw a road at a specified vertical position."
            }
          },
          {
            "step_6": {
              "code_line": "pygame.draw.rect(screen, BLACK, [...])",
              "description": "We draw a black rectangle to represent the road."
            }
          },
          {
            "step_7": {
              "code_line": "for x in range(0, width, dash_length * 2):",
              "description": "We loop through the width of the screen to create dashed lines on the road."
            }
          },
          {
            "step_8": {
              "code_line": "pygame.draw.rect(screen, WHITE, [...])",
              "description": "We draw white rectangles to represent the dashed lane markings."
            }
          },
          {
            "step_9": {
              "code_line": "pygame.display.flip()",
              "description": "We update the display to show the drawn background."
            }
          },
          {
            "step_10": {
              "code_line": "while running:",
              "description": "We enter the main loop to keep the window open and responsive."
            }
          }
        ]
      }
    },
    "task_8": {
    "title": "Size of the Picture",
    "type": "practical",
    "description": "Import the Pygame module. Load the image 'car.png'. Get the width and height of the image and print them.",
    "explanation": {
      "beginner": {
        "title": "Understanding Image Size",
        "content": [
          {
            "tag": "concept",
            "text": "Images are often used in games, and knowing their dimensions helps with layout and design."
          },
          {
            "tag": "action",
            "text": "We will load an image and retrieve its width and height using Pygame functions."
          },
          {
            "tag": "tool",
            "text": "Pygame's `load` method allows us to work with image files easily."
          }
        ]
      },
      "intermediate": {
        "title": "How Does This Work?",
        "content": [
          {
            "tag": "loading",
            "text": "The `pygame.image.load` function loads the image file into memory so we can use it in our game."
          },
          {
            "tag": "dimensions",
            "text": "The `get_width()` and `get_height()` methods allow us to access the image's dimensions directly."
          },
          {
            "tag": "printing",
            "text": "Using Python's print function, we can display the image's size, which is helpful for debugging."
          }
        ]
      },
      "advanced": {
        "title": "Advanced Considerations",
        "content": [
          {
            "tag": "performance",
            "text": "Loading large images can affect performance; optimizing image size is crucial for smooth gameplay."
          },
          {
            "tag": "aspect_ratio",
            "text": "Maintaining the aspect ratio when resizing images ensures they look correct in the game."
          },
          {
            "tag": "image_formats",
            "text": "Understanding different image formats (PNG, JPEG, etc.) can help in choosing the right one for your game."
          }
        ]
      }
    },
    "solution": {
      "code": "import pygame\nimport sys\n\n# Initialize Pygame\npygame.init()\n\n# Load the image\nimage_path = 'car.png'  # Make sure car.png is in the same directory\ncar_image = pygame.image.load(image_path)\n\n# Get the dimensions of the image\nimage_width = car_image.get_width()\nimage_height = car_image.get_height()\n\n# Print the dimensions\nprint(f\"Image width: {image_width} height: {image_height}\")\n\n# Create a display window (optional)\nscreen = pygame.display.set_mode((image_width, image_height))\npygame.display.set_caption(\"Image Size Display\")\n\n# Main loop (optional, just to keep the window open)\nwhile True:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n    \n    # Fill the screen with white\n    screen.fill((255, 255, 255))\n    \n    # Draw the image on the screen\n    screen.blit(car_image, (0, 0))\n    \n    # Update the display\n    pygame.display.flip()",
      "steps": [
        {
          "step_1": {
            "code_line": "import pygame",
            "description": "We import the Pygame library to use its functionalities."
          }
        },
        {
          "step_2": {
            "code_line": "pygame.init()",
            "description": "We initialize all Pygame modules."
          }
        },
        {
          "step_3": {
            "code_line": "car_image = pygame.image.load(image_path)",
            "description": "We load the image file 'car.png' into memory."
          }
        },
        {
          "step_4": {
            "code_line": "image_width = car_image.get_width()",
            "description": "We retrieve the width of the loaded image."
          }
        },
        {
          "step_5": {
            "code_line": "image_height = car_image.get_height()",
            "description": "We retrieve the height of the loaded image."
          }
        },
        {
          "step_6": {
            "code_line": "print(f\"Image width: {image_width} height: {image_height}\")",
            "description": "We print the dimensions of the image to the console."
          }
        },
        {
          "step_7": {
            "code_line": "screen = pygame.display.set_mode((image_width, image_height))",
            "description": "We create a display window using the dimensions of the image."
          }
        },
        {
          "step_8": {
            "code_line": "screen.blit(car_image, (0, 0))",
            "description": "We draw the loaded image onto the screen."
          }
        },
        {
          "step_9": {
            "code_line": "while True:",
            "description": "We enter the main loop to keep the window open and responsive."
          }
        }
      ]
    }
  },
  "task_9": {
    "title": "Car Driving - 1",
    "type": "practical",
    "description": "Using the background created in the previous step, implement the movement of a car across the screen.",
    "explanation": {
      "beginner": {
        "title": "Understanding Car Movement",
        "content": [
          {
            "tag": "concept",
            "text": "In this task, we'll animate a car moving across the screen from left to right and back."
          },
          {
            "tag": "action",
            "text": "We'll use Pygame to handle the graphics and animations."
          },
          {
            "tag": "tool",
            "text": "The `blit` method is crucial for rendering images in Pygame."
          }
        ]
      },
      "intermediate": {
        "title": "How the Code Works",
        "content": [
          {
            "tag": "animation",
            "text": "The car's position is updated based on speed and direction, allowing it to move smoothly across the screen."
          },
          {
            "tag": "direction",
            "text": "The direction is controlled by a variable `k`, which switches between left and right movement."
          },
          {
            "tag": "image_loading",
            "text": "Different car images are loaded depending on the direction, enhancing the visual effect."
          }
        ]
      },
      "advanced": {
        "title": "Optimization and Enhancements",
        "content": [
          {
            "tag": "frame_rate",
            "text": "Controlling the frame rate using `pygame.time.Clock()` helps maintain a consistent speed."
          },
          {
            "tag": "collision_detection",
            "text": "Collision detection can be implemented for more complex interactions (e.g., stopping at screen edges)."
          },
          {
            "tag": "dynamic_background",
            "text": "Consider adding a moving background to enhance the illusion of movement."
          }
        ]
      }
    },
    "solution": {
      "code": "import pygame\nimport sys\n\n# Initialize Pygame\npygame.init()\n\n# Initialize the Pygame clock to control the frame rate\nclock = pygame.time.Clock()\nfps = 50  # Frames per second\nv = 200  # Speed of the car\ncar = pygame.image.load('car2.png')  # Load the initial car image\nw, h = car.get_size()  # Get the width and height of the car image\nx = 20  # Initial x position of the car\nk = 1  # Direction of movement (1 for right, -1 for left)\ny = 60  # Initial y position of the car\n\n# Create a display window\nscreen = pygame.display.set_mode((800, 600))\n\n# Function to draw the road (assumed to be defined elsewhere)\ndef road():\n    # Placeholder for the road drawing function\n    pass\n\nrunning = True  # Game loop flag\n\n# Main game loop\nwhile running:\n    for event in pygame.event.get():  # Handle events\n        if event.type == pygame.QUIT:  # If the quit event is triggered\n            running = False  # Exit the loop\n\n    road()  # Call a function to draw the road\n    screen.blit(car, (x, y))  # Draw the car on the screen at position (x, y)\n\n    # Check if the car has moved beyond the right border of the window\n    if x > 500:\n        k = -1  # Change direction to left\n        y = 40  # Adjust y position\n        car = pygame.image.load('car.png')  # Load the alternative car image\n\n    # Check if the car has moved beyond the left border of the window\n    if x < 1 - w:\n        k = 1  # Change direction to right\n        y = 60  # Reset y position\n        car = pygame.image.load('car2.png')  # Load the original car image\n\n    # Update the x position based on speed and direction\n    x += v / fps * k\n    clock.tick(fps)  # Limit the frame rate to the specified fps\n    pygame.display.flip()  # Update the display\n\npygame.quit()  # Exit Pygame",
      "steps": [
        {
          "step_1": {
            "code_line": "import pygame",
            "description": "We import the Pygame library to access its functionalities."
          }
        },
        {
          "step_2": {
            "code_line": "pygame.init()",
            "description": "We initialize Pygame and its modules."
          }
        },
        {
          "step_3": {
            "code_line": "clock = pygame.time.Clock()",
            "description": "We create a clock to manage the frame rate."
          }
        },
        {
          "step_4": {
            "code_line": "fps = 50",
            "description": "We set the desired frames per second for the game."
          }
        },
        {
          "step_5": {
            "code_line": "car = pygame.image.load('car2.png')",
            "description": "We load the initial car image for the animation."
          }
        },
        {
          "step_6": {
            "code_line": "w, h = car.get_size()",
            "description": "We retrieve the dimensions of the car image for boundary checks."
          }
        },
        {
          "step_7": {
            "code_line": "x = 20",
            "description": "We initialize the x position of the car."
          }
        },
        {
          "step_8": {
            "code_line": "k = 1",
            "description": "We set the initial direction of movement to right."
          }
        },
        {
          "step_9": {
            "code_line": "while running:",
            "description": "We start the main game loop, which will run until the user quits."
          }
        },
        {
          "step_10": {
            "code_line": "road()",
            "description": "We call a function to draw the road (assumed to be defined elsewhere)."
          }
        },
        {
          "step_11": {
            "code_line": "screen.blit(car, (x, y))",
            "description": "We draw the car image at its current position."
          }
        },
        {
          "step_12": {
            "code_line": "x += v / fps * k",
            "description": "We update the x position based on speed and direction."
          }
        },
        {
          "step_13": {
            "code_line": "pygame.display.flip()",
            "description": "We update the display to show the latest frame."
          }
        }
      ]
    }
  },
    "task_10": {
      "title": "Car Driving - 2",
      "type": "practical",
      "description": "Using the previously defined road and car images, implement the movement of a car that moves smoothly left and right across multiple lanes.",
      "explanation": {
        "beginner": {
          "title": "Understanding the Car Movement",
          "content": [
            {
              "tag": "concept",
              "text": "In this task, we will animate a car moving horizontally across a series of roads."
            },
            {
              "tag": "action",
              "text": "The car will switch directions when it reaches the edge of the window."
            },
            {
              "tag": "tool",
              "text": "The `blit` method is used to draw the car on the screen."
            }
          ]
        },
        "intermediate": {
          "title": "How the Code Functions",
          "content": [
            {
              "tag": "movement",
              "text": "The car's position is updated based on the current direction, and the direction changes upon hitting the window edges."
            },
            {
              "tag": "road_navigation",
              "text": "The car changes lanes when it reaches the left edge after moving left."
            },
            {
              "tag": "image_flipping",
              "text": "The car's orientation is adjusted by loading two images: one facing left and one facing right."
            }
          ]
        },
        "advanced": {
          "title": "Optimization and Enhancements",
          "content": [
            {
              "tag": "frame_rate_control",
              "text": "Using `pygame.time.Clock()` allows for consistent animation speed regardless of processing power."
            },
            {
              "tag": "dynamic_lanes",
              "text": "You can add more lanes or dynamic road elements to create a more engaging simulation."
            },
            {
              "tag": "collision_detection",
              "text": "Consider adding obstacle detection or collision mechanics for a more interactive experience."
            }
          ]
        }
      },
      "solution": {
        "code": "import pygame\n\n# Initialize Pygame\npygame.init()\n\n# Set the dimensions of the window\nwidth, height = 800, 600\nscreen = pygame.display.set_mode((width, height))\n\n# Define colors\nGREEN = (0, 128, 0)\nBLACK = (0, 0, 0)\nWHITE = (255, 255, 255)\n\n# Load the car images for left and right directions\ncar_left = pygame.image.load('car.png')  # Facing left\ncar_right = pygame.transform.flip(car_left, True, False)  # Flip to face right\ncar_width, car_height = car_left.get_size()\n\n# Fill background with green color\nscreen.fill(GREEN)\n\n# Function to draw roads with dashed lines\ndef draw_road(y_position):\n    road_height = 80  # Height for wider roads\n    dash_length = 20\n    \n    # Draw the road rectangle\n    pygame.draw.rect(screen, BLACK, [0, y_position - road_height // 2, width, road_height])\n    \n    # Draw dashed lines on the road\n    for x in range(0, width, dash_length * 2):\n        pygame.draw.rect(screen, WHITE, [x, y_position, dash_length, 5])\n\n# Y positions for each of the five roads based on window height\nroad_positions = [height * i / 6 for i in range(1, 6)]\n\nfor pos in road_positions:\n    draw_road(pos)\n\n# Update display to show changes\npygame.display.flip()\n\n# Initial car position and road index\ncar_x = 0\ncar_y_index = 0\ndirection = 1  # 1 for moving right, -1 for moving left\nrunning = True\nclock = pygame.time.Clock()\n\n# Main loop to keep the window open and move the car\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n\n    # Clear the screen and redraw the roads\n    screen.fill(GREEN)\n    for pos in road_positions:\n        draw_road(pos)\n\n    # Get the current road position\n    car_y = road_positions[car_y_index]\n\n    # Adjust car position based on direction\n    if direction == 1:\n        car_draw_y = car_y - car_height // 1.5  # Move slightly higher for right movement\n        screen.blit(car_right, (car_x, car_draw_y))  # Draw car facing right\n    else:\n        car_draw_y = car_y - car_height // 3.6  # Move slightly higher for left movement\n        screen.blit(car_left, (car_x, car_draw_y))  # Draw car facing left\n\n    # Update car position\n    car_x += 5 * direction  # Move right or left based on direction\n\n    # Check if the car has reached the end of the road\n    if direction == 1 and car_x > width:  # Moving right\n        car_x = width  # Keep at the right edge\n        direction = -1  # Change direction to left\n    elif direction == -1 and car_x < -car_width:  # Moving left\n        car_x = 0  # Reset car position to the left\n        direction = 1  # Change direction to right\n        car_y_index += 1  # Move to the next road\n\n        # Check if all roads have been traversed\n        if car_y_index >= len(road_positions):\n            car_y_index = 0  # Reset to the first road\n\n    # Update the display\n    pygame.display.flip()\n    clock.tick(60)  # Limit the frame rate to 60 FPS\n\npygame.quit()",
        "steps": [
          {
            "step_1": {
              "code_line": "import pygame",
              "description": "Import the Pygame library to utilize its functionalities."
            }
          },
          {
            "step_2": {
              "code_line": "pygame.init()",
              "description": "Initialize Pygame and its modules."
            }
          },
          {
            "step_3": {
              "code_line": "screen = pygame.display.set_mode((width, height))",
              "description": "Create the display window with specified dimensions."
            }
          },
          {
            "step_4": {
              "code_line": "car_left = pygame.image.load('car.png')",
              "description": "Load the image of the car facing left."
            }
          },
          {
            "step_5": {
              "code_line": "car_right = pygame.transform.flip(car_left, True, False)",
              "description": "Flip the car image horizontally to create a right-facing version."
            }
          },
          {
            "step_6": {
              "code_line": "road_positions = [height * i / 6 for i in range(1, 6)]",
              "description": "Calculate the vertical positions of the roads."
            }
          },
          {
            "step_7": {
              "code_line": "for pos in road_positions: draw_road(pos)",
              "description": "Draw the roads on the screen at their respective positions."
            }
          },
          {
            "step_8": {
              "code_line": "car_x += 5 * direction",
              "description": "Update the car's x position based on the current direction."
            }
          },
          {
            "step_9": {
              "code_line": "if direction == 1 and car_x > width: direction = -1",
              "description": "Check if the car has reached the right edge; if so, change direction to left."
            }
          },
          {
            "step_10": {
              "code_line": "elif direction == -1 and car_x < -car_width: direction = 1",
              "description": "Check if the car has reached the left edge; if so, change direction to right and move to the next road."
            }
          },
          {
            "step_11": {
              "code_line": "pygame.display.flip()",
              "description": "Update the display to show the latest frame."
            }
          },
          {
            "step_12": {
              "code_line": "clock.tick(60)",
              "description": "Control the frame rate to ensure smooth animation."
            }
          }
        ]
      }
    },
    "task_11": {
    "title": "Infinity Movement",
    "type": "practical",
    "description": "Write a program to create the infinity movement of an object like in the animation below. The object will move and bounce within the screen boundaries, reversing direction upon hitting the edges.",
    "explanation": {
      "beginner": {
        "title": "Basic Concept of Movement",
        "content": [
          {
            "tag": "concept",
            "text": "In this task, the object (a ball) moves continuously in all directions. When it hits the screen edges, it bounces back."
          },
          {
            "tag": "action",
            "text": "The ball's position is updated every frame, and the direction changes upon hitting any screen boundary."
          },
          {
            "tag": "tool",
            "text": "We use Pygame to handle the screen display, ball movement, and event handling."
          }
        ]
      },
      "intermediate": {
        "title": "Understanding Ball Movement and Screen Boundaries",
        "content": [
          {
            "tag": "movement",
            "text": "The ball's x and y positions are updated based on the current speed in both axes. Upon hitting the window edges, the speed reverses for either the x or y direction."
          },
          {
            "tag": "boundary_detection",
            "text": "We detect screen boundaries by checking if the ball's current position plus or minus its radius is beyond the screen size."
          },
          {
            "tag": "speed_adjustment",
            "text": "The ball's speed is set to a constant value for smooth movement."
          }
        ]
      },
      "advanced": {
        "title": "Optimizing Performance and Enhancing Animation",
        "content": [
          {
            "tag": "frame_rate_control",
            "text": "We use `pygame.time.Clock()` to limit the frame rate to ensure smooth animation and avoid CPU overload."
          },
          {
            "tag": "customization",
            "text": "You can modify the speed, size of the ball, or the screen dimensions to create different effects and behaviors."
          },
          {
            "tag": "collision_effects",
            "text": "To make the animation more engaging, you could add effects like changing ball color upon impact."
          }
        ]
      }
    },
    "solution": {
      "code": "import pygame\n\n# Initialize Pygame\npygame.init()\n\n# Set up the display\nwidth, height = 800, 600\nscreen = pygame.display.set_mode((width, height))\npygame.display.set_caption('Infinity Bouncing Ball')\n\n# Define colors\nBLACK = (0, 0, 0)\nWHITE = (255, 255, 255)\n\n# Ball parameters\nball_radius = 20\nball_x = width // 2\nball_y = height // 2\nball_speed_x = 5\nball_speed_y = 5\n\n# Main loop\nrunning = True\nclock = pygame.time.Clock()\n\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n\n    # Clear the screen\n    screen.fill(BLACK)\n\n    # Update ball position\n    ball_x += ball_speed_x\n    ball_y += ball_speed_y\n\n    # Check if the ball hits the edges and reverse direction\n    if ball_x - ball_radius < 0 or ball_x + ball_radius > width:\n        ball_speed_x = -ball_speed_x\n    if ball_y - ball_radius < 0 or ball_y + ball_radius > height:\n        ball_speed_y = -ball_speed_y\n\n    # Draw the ball\n    pygame.draw.circle(screen, WHITE, (ball_x, ball_y), ball_radius)\n\n    # Update the display\n    pygame.display.flip()\n\n    # Limit the frame rate\n    clock.tick(60)\n\npygame.quit()",
      "steps": [
        {
          "step_1": {
            "code_line": "import pygame",
            "description": "Import the Pygame library to handle the display and animation."
          }
        },
        {
          "step_2": {
            "code_line": "pygame.init()",
            "description": "Initialize Pygame and its modules to begin."
          }
        },
        {
          "step_3": {
            "code_line": "screen = pygame.display.set_mode((width, height))",
            "description": "Create the display window with defined dimensions."
          }
        },
        {
          "step_4": {
            "code_line": "ball_x += ball_speed_x",
            "description": "Update the ball's x-coordinate by adding its speed."
          }
        },
        {
          "step_5": {
            "code_line": "if ball_x - ball_radius < 0 or ball_x + ball_radius > width:",
            "description": "Check if the ball has hit the left or right edge of the screen and reverse its horizontal direction."
          }
        },
        {
          "step_6": {
            "code_line": "pygame.draw.circle(screen, WHITE, (ball_x, ball_y), ball_radius)",
            "description": "Draw the ball at the updated position."
          }
        },
        {
          "step_7": {
            "code_line": "pygame.display.flip()",
            "description": "Update the display to show the latest frame with the ball's new position."
          }
        },
        {
          "step_8": {
            "code_line": "clock.tick(60)",
            "description": "Limit the frame rate to ensure smooth animation."
          }
        }
      ]
    }
  }
        }
    }
}
